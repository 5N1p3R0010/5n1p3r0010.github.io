<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="近日，有安全研究员在github上公开了”CVE-2021-1675”的exp PrintNightmare，后经验证公开的exp是一个与CVE-2021-1675不同的漏洞，微软为其分配了新的编号CVE-2021-34527。这篇文章记录了CVE-2021-34527的复现过程，并对漏洞成因进行了简单的分析。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Windows Print Spooler RCE CVE-2021-34527 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Windows/" rel="tag">Windows</a></div><div class="post-time">2021-07-09</div></div></div><div class="container post-header"><h1>Windows Print Spooler RCE CVE-2021-34527</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">漏洞复现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">环境配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">复现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A0%B9%E5%8E%9F"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞根原</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InternalAddPrinterDriverEx"><span class="toc-number">2.2.</span> <span class="toc-text">InternalAddPrinterDriverEx</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ValidateDriverInfo"><span class="toc-number">2.2.1.</span> <span class="toc-text">ValidateDriverInfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CreateInternalDriverFileArray"><span class="toc-number">2.2.2.</span> <span class="toc-text">CreateInternalDriverFileArray</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SplIsCompatibleDriver"><span class="toc-number">2.2.3.</span> <span class="toc-text">SplIsCompatibleDriver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CopyFilesToFinalDirectory"><span class="toc-number">2.2.4.</span> <span class="toc-text">CopyFilesToFinalDirectory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>近日，有安全研究员在github上公开了”CVE-2021-1675”的exp PrintNightmare，后经验证公开的exp是一个与CVE-2021-1675不同的漏洞，微软为其分配了新的编号CVE-2021-34527。这篇文章记录了CVE-2021-34527的复现过程，并对漏洞成因进行了简单的分析。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>​    这里记录域控环境下使用普通权限域账户实现RCE反弹<code>nt authority\system</code> shell的过程。下面的漏洞复现和漏洞分析都是基于Windows server 2019，2021-6补丁的，winver=17763.1999。经笔者测试在无任何补丁的Windows server 2019，winver=17763.107环境下使用以下步骤也可以复现RCE。</p>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>实现RCE的条件如下：</p>
<p>1.一个普通权限的域账户，用另一台计算机使用该域账户登录加入域环境。其中域账户权限如下</p>
<p><img src="image-20210708152517603.png" alt="image-20210708152517603"></p>
<p>2.域控主机需要能够访问到使用上述配置登录的计算机的一个共享目录，在Windows下可以使用smb实现，用管理员权限的powershell运行以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir C:\share</span><br><span class="line">icacls C:\share\ &#x2F;T &#x2F;grant Anonymous&#96; logon:r</span><br><span class="line">icacls C:\share\ &#x2F;T &#x2F;grant Everyone:r</span><br><span class="line">New-SmbShare -Path C:\share -Name share -ReadAccess &#39;ANONYMOUS LOGON&#39;,&#39;Everyone&#39;</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; &#x2F;v NullSessionPipes &#x2F;t REG_MULTI_SZ &#x2F;d srvsvc &#x2F;f</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot; &#x2F;v NullSessionShares &#x2F;t REG_MULTI_SZ &#x2F;d share &#x2F;f</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; &#x2F;v EveryoneIncludesAnonymous &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f</span><br><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; &#x2F;v RestrictAnonymous &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f</span><br></pre></td></tr></table></figure>

<p>运行完命令重启生效。</p>
<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>​    GitHub上有2个公开的exp，python版本的<a target="_blank" rel="noopener" href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a> 和C++版本的<a target="_blank" rel="noopener" href="https://github.com/afwu/PrintNightmare">https://github.com/afwu/PrintNightmare</a> ，其中C++版本的是从Zhiniang Peng (@edwardzpeng) &amp; Xuefeng Li (@lxf02942370)公开的exp fork来的。</p>
<p>​    这两个版本的exp原理都是一样的，也都是可用的，其中python版本的exp需要按照说明文档安装exp作者的impacket库，其余不需要修改任何东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip3 uninstall impacket</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;cube0x0&#x2F;impacket</span><br><span class="line">cd impacket</span><br><span class="line">python3 .&#x2F;setup.py install</span><br></pre></td></tr></table></figure>

<p>​    c++版本的exp需要把第112行UNIDRV.DLL的路径修改为域控主机对应的路径，如笔者这里对应的路径应修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;info.pDriverPath &#x3D; (LPWSTR)L&quot;C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_19a3fe50fa9a21b6\\Amd64\\UNIDRV.DLL&quot;;</span><br><span class="line">info.pDriverPath &#x3D; (LPWSTR)L&quot;C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_83aa9aebf5dffc96\\Amd64\\UNIDRV.DLL&quot;;</span><br></pre></td></tr></table></figure>

<p>其余不需要修改任何东西，使用vs编译即可。</p>
<p>​    python版本exp命令及RCE截图：</p>
<p><img src="reproduce.png" alt="reproduce"></p>
<p>​    c++版本exp命令及RCE截图：<img src="image-20210708154509121.png" alt="image-20210708154509121"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="漏洞根原"><a href="#漏洞根原" class="headerlink" title="漏洞根原"></a>漏洞根原</h4><p>​    漏洞的关键在于localspl!SplAddPrinterDriverEx中调用InternalAddPrinterDriverEx加载驱动前的验证ValidateObjectAccess是可以被跳过的。如下localspl!SplAddPrinterDriverEx中的汇编代码为存在漏洞可以导致ValidateObjectAccess被绕过的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000180085F25 loc_180085F25:                          ; CODE XREF: SplAddPrinterDriverEx+3F↑j</span><br><span class="line">.text:0000000180085F25                 bt      esi, 0Fh        ; esi&#x3D;dwFileCopyFlags</span><br><span class="line">.text:0000000180085F29                 mov     ebx, 0</span><br><span class="line">.text:0000000180085F2E                 cmovnb  ebx, [rsp+58h+arg_30] ; [rsp+0x90]&#x3D;1</span><br><span class="line">.text:0000000180085F2E                                         ; CF&#x3D;1,不进行移位</span><br><span class="line">.text:0000000180085F36                 test    ebx, ebx</span><br><span class="line">.text:0000000180085F38                 jz      short loc_180085F64</span><br><span class="line">.text:0000000180085F3A                 mov     rax, cs:pLocalIniSpooler</span><br><span class="line">.text:0000000180085F41                 xor     r9d, r9d</span><br><span class="line">.text:0000000180085F44                 and     [rsp+58h+var_30], 0</span><br><span class="line">.text:0000000180085F49                 xor     r8d, r8d</span><br><span class="line">.text:0000000180085F4C                 xor     ecx, ecx</span><br><span class="line">.text:0000000180085F4E                 mov     [rsp+58h+var_38], rax</span><br><span class="line">.text:0000000180085F53                 lea     edx, [r9+1]</span><br><span class="line">.text:0000000180085F57                 call    ?ValidateObjectAccess@@YAHKKPEAXPEAKPEAU_INISPOOLER@@W4SERVER_MANAGEMENT_ACCESS_REQUEST@@@Z ; ValidateObjectAccess(ulong,ulong,void *,ulong *,_INISPOOLER *,SERVER_MANAGEMENT_ACCESS_REQUEST)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.text:0000000180085F64 loc_180085F64:                          ; CODE XREF: SplAddPrinterDriverEx+98↑j</span><br><span class="line">.text:0000000180085F64                                         ; SplAddPrinterDriverEx+BE↑j</span><br><span class="line">.text:0000000180085F64                 and     [rsp+58h+var_20], 0</span><br><span class="line">.text:0000000180085F6A                 mov     r9d, esi</span><br><span class="line">.text:0000000180085F6D                 mov     eax, [rsp+58h+arg_28]</span><br><span class="line">.text:0000000180085F74                 mov     r8, r14</span><br><span class="line">.text:0000000180085F77                 mov     [rsp+58h+var_28], ebx</span><br><span class="line">.text:0000000180085F7B                 mov     edx, r15d</span><br><span class="line">.text:0000000180085F7E                 mov     [rsp+58h+var_30], eax</span><br><span class="line">.text:0000000180085F82                 mov     rcx, rdi</span><br><span class="line">.text:0000000180085F85                 mov     [rsp+58h+var_38], rbp</span><br><span class="line">.text:0000000180085F8A                 call    InternalAddPrinterDriverEx</span><br></pre></td></tr></table></figure>

<p>其中esi为dwFileCopyFlags，是一个调用者可控的参数，<code>bt esi,0xf</code> 将esi中偏移0xf的比特位保存到CF标志位，即CF标志位与esi的0x10比特位相同，dwFileCopyFlags=0x8014时CF=1。<code>cmovnb  ebx, [rsp+58h+arg_30]</code>  即mov if not below，cmovnb会检测CF标志位是否为0且当CF为0时进行移位操作，此时[rsp+0x90]=1，CF=1不会将ebx赋值为1。调试现场如下</p>
<p><img src="image-20210708164408188.png" alt="image-20210708164408188"></p>
<p>由于ebx=0，<code>jz short loc_180085F64</code> 会跳转到InternalAddPrinterDriverEx处执行后续复制并加载驱动的操作，跳过了0x180085F57处ValidateObjectAccess的检测。</p>
<h4 id="InternalAddPrinterDriverEx"><a href="#InternalAddPrinterDriverEx" class="headerlink" title="InternalAddPrinterDriverEx"></a>InternalAddPrinterDriverEx</h4><p>​    RpcAddPrinterDriverEx会在spoolsv!RpcAddPrinterDriverEx处解析，调用到localspl!LocalAddPrinterDriverEx处的回调，并最终由于localspl!SplAddPrinterDriverEx处的验证ValidateObjectAccess无效导致可以调用到localspl!InternalAddPrinterDriverEx加载驱动并执行。</p>
<p>​    调用到localspl!SplAddPrinterDriverEx时的栈回溯如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:009&gt; k</span><br><span class="line"> # Child-SP          RetAddr           Call Site</span><br><span class="line">00 0000001f&#96;7f83e938 00007ffc&#96;fb225852 localspl!SplAddPrinterDriverEx</span><br><span class="line">01 0000001f&#96;7f83e940 00007ff6&#96;6c23ba9f localspl!LocalAddPrinterDriverEx+0xa2</span><br><span class="line">02 0000001f&#96;7f83e990 00007ff6&#96;6c215ffe spoolsv!AddPrinterDriverExW+0x6f</span><br><span class="line">03 0000001f&#96;7f83e9d0 00007ff6&#96;6c212c71 spoolsv!YAddPrinterDriverEx+0x2ce</span><br><span class="line">04 0000001f&#96;7f83ea10 00007ffd&#96;027184a3 spoolsv!RpcAddPrinterDriverEx+0x181</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​    2021-6的补丁中在spoolsv!RpcAddPrinterDriverEx中调用YAddPrinterDriverEx加载驱动前加了几处校验，如下右为补丁后的spoolsv.exe。补丁后YIsElevated、RunningAsLUA分别校验了当前用户的token和LUA权限，这两处校验在RCE中可以通过IPC被绕过；YIsElevationRequired检验了<code>HKEY_LOCAL_MACHINE\Software\\Policies\\Microsoft\\Windows NT\\Printers\\PointAndPrint\NoWarningNoElevationOnInstall</code> 的注册表项，但是笔者在2021-6全补丁的Windows server和Windows10系统上均未发现有该注册表项，所以这个缓解在目前来看也是无效的。（这两处缓解可能是针对Yunhai Zhang和ZhiPeng Huo提供的CVE-2021-1675的poc）</p>
<p><img src="image-20210709083243361.png" alt="image-20210709083243361"></p>
<p>​    随后由于spoolsv!AddPrinterDriverExW调用到localspl!LocalAddPrinterDriverEx处的回调，又由于上述分析的localspl!SplAddPrinterDriverEx中验证无效进入localspl!InternalAddPrinterDriverEx的流程。</p>
<p>​    localspl!InternalAddPrinterDriverEx主要进行了如下操作，其中<code>%spooler%=C:\Windows\System32\spool\</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ValidateDriverInfo进行驱动签名等的检查</span><br><span class="line">2.CreateInternalDriverFileArray创建spooler目录下的驱动文件，即%spooler%\drivers\x64</span><br><span class="line">3.GetPrintDriverVersion、CheckFilePlatform检查驱动版本和驱动运行平台</span><br><span class="line">4.SplIsCompatibleDriver进行驱动版本和驱动兼容性检查，驱动版本号只能为3</span><br><span class="line">5.CreateVersionDirectory使用提供的驱动版本号，创建spooler目录下驱动版本号目录，由于驱动版本号只能为3，最终目录为%spooler%\drivers\x64\3</span><br><span class="line">6.CopyFilesToFinalDirectory创建%spooler%\3目录下New、Old文件夹，创建New、Old目录下的临时目录，如%spooler%\drivers\x64\3\Old\1、%spooler%\drivers\x64\3\Old\2；并将上传的驱动移动到临时目录下</span><br><span class="line">7.WaitRequiredForDriverUnload加载6中临时目录下的驱动，路径如%spooler%\drivers\x64\3\old\1\xx.dll</span><br></pre></td></tr></table></figure>

<h5 id="ValidateDriverInfo"><a href="#ValidateDriverInfo" class="headerlink" title="ValidateDriverInfo"></a>ValidateDriverInfo</h5><p>​        localspl!ValidateDriverInfo在如下代码会校验加载驱动的签名，可以使用0x8000的dwFileCopyFlags绕过，0x8000即RpcAddPrinterDriverEx 的API文档中提到的APD_INSTALL_WARNED_DRIVER，翻译过来即强制加载驱动。<img src="image-20210709090019330.png" alt="image-20210709090019330"></p>
<h5 id="CreateInternalDriverFileArray"><a href="#CreateInternalDriverFileArray" class="headerlink" title="CreateInternalDriverFileArray"></a>CreateInternalDriverFileArray</h5><p>​    localspl!CreateInternalDriverFileArray中会使用如下代码根据RpcAddPrinterDriverEx 的dwFileCopyFlags参数生成CreateFile的参数，a5=1会使用%spooler%目录下路径做为CreateFile的参数；RCE利用时我们上传的驱动此时是在一个UNC路径下，如笔者本地为<code>\\192.168.18.153\share\rev.dll</code> ，所以这里需要构造dwFileCopyFlags&amp;0x10=1使spooler使用我们的UNC路径。</p>
<p><img src="image-20210709090932362.png" alt="image-20210709090932362"></p>
<p>其中a5参数从localspl!LocalAddPrinterDriverEx这里传入，</p>
<p><img src="image-20210709091622421.png" alt="image-20210709091622421"></p>
<h5 id="SplIsCompatibleDriver"><a href="#SplIsCompatibleDriver" class="headerlink" title="SplIsCompatibleDriver"></a>SplIsCompatibleDriver</h5><p>​    localspl!SplIsCompatibleDriver会检查将要加载的驱动的版本号，版本号v117只能为3</p>
<p><img src="image-20210709091810684.png" alt="image-20210709091810684"></p>
<p>其中v117会在localspl!InternalAddPrinterDriverEx这里校验两次，v117==2和v117&gt;3都会导致驱动加载失败。</p>
<p><img src="image-20210709091925228.png" alt="image-20210709091925228"></p>
<p>​    localspl!SplIsCompatibleDriver检查驱动兼容性时会调用到ntprint!PSetupIsCompatibleDriver，最终会调用到如下代码，其中a6=v117为驱动版本号，当v117&lt;=2时返回0会导致驱动加载失败。</p>
<p><img src="image-20210709092214431.png" alt="image-20210709092214431"></p>
<p>综上，当v117==2、v117&gt;3、v117&lt;=2时均会最终导致驱动加载失败，v117只能为3。</p>
<h5 id="CopyFilesToFinalDirectory"><a href="#CopyFilesToFinalDirectory" class="headerlink" title="CopyFilesToFinalDirectory"></a>CopyFilesToFinalDirectory</h5><p>​    localspl!CopyFilesToFinalDirectory主要是创建%spooler%\drivers\x64\3\New、%spooler%\drivers\x64\3\Old，并创建临时目录如</p>
<p>%spooler%\drivers\x64\3\Old\1，将UNIDRV.DLL、kernelbase.dll、rev.dll依次从C:\Windows\System32\spool\drivers\x64\3\New、C:\Windows\System32\spool\drivers\x64\3里使用MoveFileExW移动到%spooler%\drivers\x64\3\Old\1里。</p>
<p><img src="New_to_Old.png" alt="New_to_Old"></p>
<p>最终在localspl!CompleteDriverUpgrade里更新所加载驱动的信息并加载上述临时目录下的驱动。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    据Zhiniang Peng (@edwardzpeng) &amp; Xuefeng Li (@lxf02942370)在最初公开的exp README里描述，spooler的漏洞最初用于10年前的震网（Stuxnet）攻击，10年间spooler模块也被披露了许多漏洞，但不知是因为微软补丁修复的不彻底还是spooler模块本身实现起来的复杂性导致了CVE-2021-1675和CVE-2021-34527的出现。微软已于2021.7.7发布了一个紧急安全更新补丁，希望微软的这个补丁能使spooler更安全一些吧;p</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/afwu/PrintNightmare">https://github.com/afwu/PrintNightmare</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>