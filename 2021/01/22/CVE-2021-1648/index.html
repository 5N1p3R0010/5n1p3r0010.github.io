<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="近日，作者分析了微软1月补丁日修复的一个漏洞CVE-2021-1648，这是一个可以在splwow64进程空间进行任意地址读写的漏洞。由于splwow64是一个普通权限的进程且splwow64在IE浏览器的白名单目录里，因此这个漏洞可以用于提权低权限的IE浏览器渲染引擎进程从而绕过IE浏览器的沙箱。这篇文章主要介绍一下splwow64的机制和CVE-2021-1648的成因。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>CVE-2021-1648 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Windows/" rel="tag">Windows</a></div><div class="post-time">2021-01-22</div></div></div><div class="container post-header"><h1>CVE-2021-1648</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#splwow64%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">splwow64机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FindDriverForCookie%E3%80%81FindPrinterHandle%E7%BB%95%E8%BF%87"><span class="toc-number">2.1.</span> <span class="toc-text">FindDriverForCookie、FindPrinterHandle绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UMPDPointerFromOffset%E3%80%81UMPDStringPointerFromOffset%E7%BB%95%E8%BF%87"><span class="toc-number">2.2.</span> <span class="toc-text">UMPDPointerFromOffset、UMPDStringPointerFromOffset绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="toc-number">2.3.</span> <span class="toc-text">任意地址读写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>近日，作者分析了微软1月补丁日修复的一个漏洞CVE-2021-1648，这是一个可以在splwow64进程空间进行任意地址读写的漏洞。由于splwow64是一个普通权限的进程且splwow64在IE浏览器的白名单目录里，因此这个漏洞可以用于提权低权限的IE浏览器渲染引擎进程从而绕过IE浏览器的沙箱。这篇文章主要介绍一下splwow64的机制和CVE-2021-1648的成因。</p>
<p>环境：Windows10 20H2 2020-12补丁</p>
<h3 id="splwow64机制"><a href="#splwow64机制" class="headerlink" title="splwow64机制"></a>splwow64机制</h3><p>​    wow64是微软为了在64bit系统兼容运行32bit程序的一个组件，具体来说，在64bit程序调用32bit的CreateDC Windows会用splwow64.exe处理这个调用，64bit程序与splwow64.exe使用lpc进行通信。</p>
<p>​    splwow64在splwow64!GDIThunkingVIALPCThread里调用NtCreatePort开启处理信息的端口，在这里我们可以计算得到调用NtSecureConnectPort与splwow64通信的端口名称</p>
<p><img src="image-20210120151720514.png" alt="image-20210120151720514"></p>
<p>​    我们可以从xp sp1代码\NT\base\ntos\lpc\lpcconn.c中NtSecureConnectPort的注释中得到一些lpc通信机制的信息，这里摘抄部分注释如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、NtSecureConnectPort通过PortName参数连接server端口，PortName必须与NtCreatePort指定的一致</span><br><span class="line">2、server端通过NtListenPort接收请求，client端在server端接收处理请求、返回NtCompleteConnectPort执行结果前阻塞</span><br><span class="line">3、server在接受请求后返回给client端一个参数PortHandle，PortHandle与名称无关与client进程有关。client使用PortHandle调用NtRequestWaitReplyPort从server端接收&#x2F;发送信息</span><br></pre></td></tr></table></figure>



<p>​    splwow64在splwow64!TLPCMgr::ProcessRequest处理接收的消息，这里过滤了传入消息的长度，只处理DataSize=0x20长度的消息，</p>
<p><img src="image-20210120152719215.png" alt="image-20210120152719215"></p>
<p>并将某些类型合法消息的[0x30],[0x40],[0x38]作为参数传递给Gdi32full!GdiPrinterThunk，这里传递的参数都是调用者可控的。</p>
<p><img src="image-20210120152836151.png" alt="image-20210120152836151"></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    CVE-2021-1648出现在0x6d消息的处理过程中，CVE-2021-1648是在CVE-2020-0986补丁的基础上出现的，CVE-2020-0986的补丁在gdi32full!GdiPrinterThunk里主要加了两个缓解FindDriverForCookie、FindPrinterHandle和UMPDPointerFromOffset、UMPDStringPointerFromOffset，由于Gdi32full!GdiPrinterThunk传入的参数可控，这两个缓解实际上都是可以绕过的。</p>
<h4 id="FindDriverForCookie、FindPrinterHandle绕过"><a href="#FindDriverForCookie、FindPrinterHandle绕过" class="headerlink" title="FindDriverForCookie、FindPrinterHandle绕过"></a>FindDriverForCookie、FindPrinterHandle绕过</h4><p>​    Gdi32full!FindDriverForCookie的功能是根据传入的值a1，从一个全局变量gdi32full+EABA0里遍历得到偏移[7]的位置为a1的地址并返回。</p>
<p><img src="image-20210120154232683.png" alt="image-20210120154232683"></p>
<p>​    Gdi32full!FindPrinterHandle的功能是根据传入的参数a1（地址值）、a2、a3，从a1偏移0x40的位置遍历，返回该地址偏移2*4=a2且3*4=a3的偏移值。</p>
<p><img src="image-20210120154512962.png" alt="image-20210120154512962"></p>
<p>这两处缓解可以通过0x6a消息调用一次gdi32full!bAddPrinterHandle来绕过，gdi32full!bAddPrinterHandle调用时参数如下，其中第二、三个参数是调用者可控的。</p>
<p><img src="image-20210120155136672.png" alt="image-20210120155136672"></p>
<p>​    gdi32full!bAddPrinterHandle的功能是把传入的a2、a3写入到global_heap偏移2*4、3*4的位置。需要注意的是这里*(QWORD*)(global_heap+0x40)的位置实际上和上文Gdi32full!FindPrinterHandle中*(a1+0x40)相同，</p>
<p><img src="image-20210120155239770.png" alt="image-20210120155239770"></p>
<p>再看一下0x6d消息是如何调用FindPrinterHandle的，这里的参数二、三是我们可控的，这样在gdi32full!bAddPrinterHandle调用中*(QWORD*)(global_heap+0x40)写入的内容和gdi32full!FindPrinterHandle中要寻找的内容位置相同且都可控，我们就可以绕过gdi32full!FindPrinterHandle这个检查。</p>
<p><img src="image-20210120155840463.png" alt="image-20210120155840463"></p>
<h4 id="UMPDPointerFromOffset、UMPDStringPointerFromOffset绕过"><a href="#UMPDPointerFromOffset、UMPDStringPointerFromOffset绕过" class="headerlink" title="UMPDPointerFromOffset、UMPDStringPointerFromOffset绕过"></a>UMPDPointerFromOffset、UMPDStringPointerFromOffset绕过</h4><p>​    CVE-2020-0986补丁加的另一个缓解是检查指针是否在32bit的范围，</p>
<p><img src="image-20210120160355257.png" alt="image-20210120160355257"></p>
<p>​    这个缓解可以绕过的原因是splwow64.exe与32bit兼容，所以splwow64中堆栈地址都是32bit范围内的，由于lpc通信过程中server端会开辟内存并拷贝client端传入的消息，我们构造0x6d畸形请求，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LpcRequest.PtrMsgSend &#x3D; (UINT64)ClientView.ViewRemoteBase;</span><br></pre></td></tr></table></figure>

<p>即发送消息的地址设置为lpc server端的堆地址即可绕过这一缓解。</p>
<p>splwow64中执行server端开辟内存拷贝的过程在splwow64!TLPCMgr::ProcessRequest</p>
<p><img src="image-20210120161526689.png" alt="image-20210120161526689"></p>
<h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>​    绕过了上述两个缓解，splwow64会调用一个src可控、dst可控的memcpy，由于这里memcpy的src和dst没有检查范围，我们可以通过修改src读dst的内容进行任意地址读，修改dst为目标地址、修改src为目标内容进行任意地址写。</p>
<p><img src="image-20210120161803928.png" alt="image-20210120161803928"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这里介绍了splwow64的一些机制并分析了CVE-2021-1648的成因，重点分析了微软针对CVE-2020-0986补丁所加的两个缓解机制的绕过，希望读者读完能有所收获。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2096">https://bugs.chromium.org/p/project-zero/issues/detail?id=2096</a></p>
<p><a target="_blank" rel="noopener" href="https://whereisk0shl.top/post/the_story_of_cve_2021_1648">https://whereisk0shl.top/post/the_story_of_cve_2021_1648</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>