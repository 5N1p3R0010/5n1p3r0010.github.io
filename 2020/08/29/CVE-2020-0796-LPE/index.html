<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="CVE-2020-0796是Windows操作系统SMB协议的一个整型溢出漏洞，该漏洞功能很强大，可以导致任意地址读写，成功利用该漏洞可以在特定版本Windows系统上实现无交互RCE。本文主要针对CVE-2020-0796导致本地任意地址写进行分析。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>CVE-2020-0796 LPE | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Windows/" rel="tag">Windows</a></div><div class="post-time">2020-08-29</div></div></div><div class="container post-header"><h1>CVE-2020-0796 LPE</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol></details></div><div class="container post-content"><p>CVE-2020-0796是Windows操作系统SMB协议的一个整型溢出漏洞，该漏洞功能很强大，可以导致任意地址读写，成功利用该漏洞可以在特定版本Windows系统上实现无交互RCE。本文主要针对CVE-2020-0796导致本地任意地址写进行分析。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​    漏洞出现在srv2!Srv2DecompressData里，逆向修改后的函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pBuffer &#x3D; SrvNetAllocateBuffer((unsigned size_t)(Header-&gt;OriginalCompressedSegmentSize + Header-&gt;Offset), 0);	&#x2F;&#x2F;0</span><br><span class="line">if(!pBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status &#x3D; SmbCompressionDecompress(</span><br><span class="line">    Header-&gt;CompressionAlgorithm,</span><br><span class="line">    *(QWORD*)Header + 16 + Header-&gt;Offset,</span><br><span class="line">    (unsigned size_t)(TotalSize - 16 - Header-&gt;Offset),&#x2F;&#x2F;1</span><br><span class="line">    *(QWORD*)pBuffer-&gt;Buffer + Header-&gt;Offset,</span><br><span class="line">    Header-&gt;OriginalCompressedSegmentSize,  &#x2F;&#x2F;uncompressed data segment size,poc set to 0xffffffff</span><br><span class="line">    &amp;FinalCompressedSize);)</span><br><span class="line">if((status &lt; 0) || (FinalCompressedSize !&#x3D; Header-&gt;OriginalCompressedSegmentSize))</span><br><span class="line">&#123;</span><br><span class="line">    SrvNetFreeBuffer(pBuffer);	&#x2F;&#x2F;2</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(Header-&gt;Offset)</span><br><span class="line">&#123;</span><br><span class="line">    memcpy(pBuffer-&gt;Buffer, (*(QWORD*)Header + 16), Header-&gt;Offset);&#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Srv2DecompressData的主要逻辑是开辟OriginalCompressedSegmentSize+Offset的内存，然后调用</p>
<p>SmbCompressionDecompress根据CompressionAlgorithm里的压缩算法将(Header + Header-&gt;Offset)的压缩数据解压复制到(pBuffer-&gt;Buffer + Header-&gt;Offset)的位置，如果(Header-&gt;Offset)存在继续复制Header-&gt;Offset的数据到pBuffer的位置。这里借用zecops的一张图理解起来应该会更清楚。</p>
<p><img src="Srv2DecompressData.png" alt="Srv2DecompressData"></p>
<p>​    漏洞的根源在于0处调用SrvNetAllocateBuffer((unsigned size_t)(Header-&gt;OriginalCompressedSegmentSize + Header-&gt;Offset), 0)开辟内存时没有检查OriginalCompressedSegmentSize+Offset是否超过了(unsigned size_t)的最大值即64位的0xffffffff。需要注意的是这里的整型溢出跟使用unsigned还是signed类型无关，因为计算机在计算整型加法时会将计算结果模pow(2, n)，unsigned类型计算时只不过是将结果转化为补码而已。可以看到微软的补丁也是加了一个函数来判断整型加的计算结果是否合法。</p>
<p><img src="patch.jpg" alt="patch"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>​    下面我们调试分析一下这个整型溢出漏洞导致堆溢出的根本原因及zecops的LPE poc。</p>
<p>​    我们首先跟进srv2!Srv2DecompressData中申请内存使用的SrvNetAllocateBuffer，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall SrvNetAllocateBuffer(unsigned __int64 size, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  idx &#x3D; 0;</span><br><span class="line">  if ( SrvDisableNetBufferLookAsideList || size &gt; 0x100100 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( size &gt; 0x1000100 )</span><br><span class="line">      return 0i64;</span><br><span class="line">    PoolPtr &#x3D; SrvNetAllocateBufferFromPool(size, size);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( size &gt; 0x1100 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 &#x3D; size - 256;</span><br><span class="line">      _BitScanReverse64((unsigned __int64 *)&amp;v14, v13);</span><br><span class="line">      _BitScanForward64((unsigned __int64 *)&amp;v15, v13);</span><br><span class="line">      if ( (_DWORD)v14 &#x3D;&#x3D; (_DWORD)v15 )</span><br><span class="line">        idx &#x3D; v14 - 12;</span><br><span class="line">      else</span><br><span class="line">        idx &#x3D; v14 - 11;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 &#x3D; SrvNetBufferLookasides[idx];           &#x2F;&#x2F; idx &#x3D; 0</span><br><span class="line">                                                &#x2F;&#x2F; chunkSize &#x3D; 0x1100</span><br><span class="line">                                                &#x2F;&#x2F; SrvNetBufferLookasides调用SrvNetAllocateBufferFromPool初始化</span><br><span class="line">	v7 &#x3D; *(_DWORD *)v6 - 1;</span><br><span class="line">    if ( (unsigned int)canary + 1 &lt; *(_DWORD *)v6 )</span><br><span class="line">      v7 &#x3D; canary + 1;</span><br><span class="line">    v8 &#x3D; v7;</span><br><span class="line">    v9 &#x3D; *(_QWORD *)(v6 + 32);</span><br><span class="line">    v10 &#x3D; *(_QWORD *)(v9 + 8 * v8);</span><br><span class="line">    if ( !*(_BYTE *)(v10 + 112) )</span><br><span class="line">      PplpLazyInitializeLookasideList(v6, *(_QWORD *)(v9 + 8 * v8));</span><br><span class="line">    ++*(_DWORD *)(v10 + 20);</span><br><span class="line">    PoolPtr &#x3D; (__int64)ExpInterlockedPopEntrySList((PSLIST_HEADER)v10);</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  return PoolPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SrvNetAllocateBuffer中主要是判断根据申请堆的大小来从 SrvNetBufferLookasides堆链表中返回堆或从</p>
<p>SrvNetAllocateBufferFromPool中申请堆，并初始化堆的一些数据结构。poc中申请的堆大小为OriginalCompressedSegmentSize+Offset=0xffffffff+0x18=0x17，</p>
<p>SrvNetBufferLookasides会返回idx=0即SrvNetBufferLookasides[0]的堆，Windows下计算lookasides堆大小的方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [hex((1 &lt;&lt; (i + 12)) + 256) for i in range(9)]</span><br><span class="line">[‘0x1100’, ‘0x2100’, ‘0x4100’, ‘0x8100’, ‘0x10100’, ‘0x20100’, ‘0x40100’, ‘0x80100’, ‘0x100100’]</span><br></pre></td></tr></table></figure>

<p>即这里SrvNetBufferLookasides[0]的堆大小为0x1100，所以zecops的poc中任意地址写前半部分字符串总长度为0x1100</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 0x1100 bytes minus the data to write</span><br><span class="line"># Send random bytes for bad compression</span><br><span class="line"># Minimum payload size must be 16 bytes, otherwise packet is dropped</span><br><span class="line">data_to_compress &#x3D; os.urandom(0x1100 - len(what))</span><br></pre></td></tr></table></figure>

<p>​    值得注意的是，这里SrvNetBufferLookasides是调用SrvNetAllocateBufferFromPool进行的初始化，在SrvNetAllocateBufferFromPool中调用ExAllocatePoolWithTag申请堆后初始化了这里使用的堆的布局.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  unsigned __int64 __fastcall SrvNetAllocateBufferFromPool(__int64 a1, unsigned __int64 size)</span><br><span class="line">&#123;</span><br><span class="line">......  </span><br><span class="line">  PoolPtr &#x3D; (char *)ExAllocatePoolWithTag((POOL_TYPE)0x200, v7, 0x3030534Cu);</span><br><span class="line">......</span><br><span class="line">  v11 &#x3D; (signed __int64)(PoolPtr + 0x50);</span><br><span class="line">  retPtr &#x3D; (unsigned __int64)&amp;PoolPtr[size + 0x57] &amp; 0xFFFFFFFFFFFFFFF8ui64;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x30) &#x3D; PoolPtr;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x50) &#x3D; (retPtr + v5 + 0x97) &amp; 0xFFFFFFFFFFFFFFF8ui64;</span><br><span class="line">  v13 &#x3D; (retPtr + 0x97) &amp; 0xFFFFFFFFFFFFFFF8ui64;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x18) &#x3D; PoolPtr + 0x50;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x38) &#x3D; v13;</span><br><span class="line">  *(_WORD *)(retPtr + 0x10) &#x3D; 0;</span><br><span class="line">  *(_WORD *)(retPtr + 0x16) &#x3D; 0;</span><br><span class="line">  *(_DWORD *)(retPtr + 0x20) &#x3D; size;</span><br><span class="line">  *(_DWORD *)(retPtr + 0x24) &#x3D; 0;</span><br><span class="line">  v14 &#x3D; ((_WORD)PoolPtr + 0x50) &amp; 0xFFF;</span><br><span class="line">  *(_DWORD *)(retPtr + 0x28) &#x3D; v7;</span><br><span class="line">  *(_DWORD *)(retPtr + 0x40) &#x3D; 0;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x48) &#x3D; 0i64;</span><br><span class="line">  *(_QWORD *)(retPtr + 0x58) &#x3D; 0i64;</span><br><span class="line">  *(_DWORD *)(retPtr + 0x60) &#x3D; 0;</span><br><span class="line">  </span><br><span class="line">  return retPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里如果申请的堆大小size=0x1100的话，返回的堆依次为(&amp;PoolPtr[0+0x57])&amp;0xFFFFFFFFFFFFFFF8=&amp;PoolPtr[0x50],(&amp;PoolPtr[0x1100+0x57])&amp;0xFFFFFFFFFFFFFFF8=&amp;PoolPtr[0x1150]。文章中截图中得到的&amp;PoolPtr为0xffffe68312afd000。poc中调用到srv2!Srv2DecompressData中SmbCompressionDecompress时解压数据复制的目标堆地址为&amp;PoolPtr[0x50]，一次调试时SmbCompressionDecompress执行的现场如下</p>
<p><img src="SmbCompressionDecompress.png" alt="SmbCompressionDecompress"></p>
<p>此时解压复制的目标堆为ffffe68312afd068，解压处理的数据大小为0x1116，由于我们前面调用SrvNetAllocateBuffer得到的堆的大小实际为0x1100，所以这里会溢出。计算得到解压后数据结束的位置为0xffffe68312afd068+0x1116=0xFFFFE68312AFE17E，但是由于poc中实际用到的解压算法nt!RtlDecompressBufferLZNT1对压缩数据字节对齐的一些处理，这里解压后数据实际上结束的位置为0xFFFFE68312AFE168，poc中为了后续提权当前进程把这里覆盖为了token+0x40的值即_SEP_TOKEN_PRIVILEGES结构体的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _token</span><br><span class="line">......</span><br><span class="line">+0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​    经过上面的步骤我们已经可以越界写一个值，如果我们从零开始构造exp的话下一步就是要找到一个方法利用这个越界写的值。回到出现漏洞的srv2!Srv2DecompressData里，在调用SmbCompressionDecompress处理完压缩数据之后进行了如下2和3的步骤，2可能存在的利用点是uaf，3可能存在的利用点是溢出或者其他memcpy容易导致的一些问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">status &#x3D; SmbCompressionDecompress(</span><br><span class="line">    Header-&gt;CompressionAlgorithm,</span><br><span class="line">    *(QWORD*)Header + 16 + Header-&gt;Offset,</span><br><span class="line">    (unsigned size_t)(TotalSize - 16 - Header-&gt;Offset),&#x2F;&#x2F;1</span><br><span class="line">    *(QWORD*)pBuffer-&gt;Buffer + Header-&gt;Offset,</span><br><span class="line">    Header-&gt;OriginalCompressedSegmentSize,  &#x2F;&#x2F;uncompressed data segment size,poc set to 0xffffffff</span><br><span class="line">    &amp;FinalCompressedSize);)</span><br><span class="line">if((status &lt; 0) || (FinalCompressedSize !&#x3D; Header-&gt;OriginalCompressedSegmentSize))</span><br><span class="line">&#123;</span><br><span class="line">    SrvNetFreeBuffer(pBuffer);	&#x2F;&#x2F;2</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(Header-&gt;Offset)</span><br><span class="line">&#123;</span><br><span class="line">    memcpy(pBuffer-&gt;Buffer, (*(QWORD*)Header + 16), Header-&gt;Offset);&#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而不幸的是，想要执行到2的流程需要SmbCompressionDecompress解压失败或者解压后的数据FinalCompressedSize和压缩数据OriginalCompressedSegmentSize不一致，正常执行解压之后status不会为负，如下在SmbCompressionDecompress中解压后会更新FinalCompressedSize为OriginalCompressedSegmentSize，所以这里如果执行了解压流程（触发了溢出）是不会执行到2的流程的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status &#x3D; RtlDecompressBufferEx2(</span><br><span class="line">        talgo,</span><br><span class="line">        tBufferCompressedData,</span><br><span class="line">        OriginalCompressedSegmentSize,</span><br><span class="line">        tCompressedDataStart,</span><br><span class="line">        tCompressedDataSize,</span><br><span class="line">        4096,</span><br><span class="line">        FinalCompressedSize,</span><br><span class="line">        pool,</span><br><span class="line">        *(_QWORD *)&amp;v18);</span><br><span class="line">if ( status &gt;&#x3D; 0 )</span><br><span class="line">  *FinalCompressedSize &#x3D; OriginalCompressedSegmentSize;</span><br></pre></td></tr></table></figure>

<p>​    再来看一下3，Offset值这里我们是可控的，所以3的流程肯定是可以执行到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001C0017F59                 mov     r8d, esi        ; Size</span><br><span class="line">.text:00000001C0017F5C                 mov     rcx, [rbx+18h]  ; Dst</span><br><span class="line">.text:00000001C0017F60                 mov     rdx, [rax+18h]</span><br><span class="line">.text:00000001C0017F64                 add     rdx, 10h        ; Src</span><br><span class="line">.text:00000001C0017F68                 call    memmove</span><br></pre></td></tr></table></figure>

<p>调试发现在执行3的过程中取dst参数时由于执行SmbCompressionDecompress解压压缩数据的过程，rbx的值已经变为了上述计算得到的第二个堆的地址&amp;PoolPtr[0x1100+0x57]&amp;0xFFFFFFFFFFFFFFF8=&amp;PoolPtr[0x1150]，即0xffffe68312afd000+0x1150=0xffffe68312afe150。</p>
<p><img src="memcpy.png" alt="memcpy"></p>
<p>这样取得的dst的参数实际上为我们前面通过溢出覆盖的值*0xFFFFE68312AFE168=0xFFFFB8047CB240E0，即当前进程_SEP_TOKEN_PRIVILEGES的地址，这样memcpy的过程实际上就是一次地址可控，内容可控的任意地址写了。同时由于取dst参数时使用的是[rbx+0x18]的值，所以poc中在0x1100长度的字符串后添加了0x18的padding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 0x18 null bytes that override the struct</span><br><span class="line">data_to_compress +&#x3D; b&quot;\x00&quot; * 0x18</span><br><span class="line"># Target address</span><br><span class="line">data_to_compress +&#x3D; struct.pack(&#39;&lt;Q&#39;, where)  # b&quot;A&quot; * 0x08</span><br></pre></td></tr></table></figure>

<p>​    有了这样一个任意地址写，覆盖_SEP_TOKEN_PRIVILEGES结构体为0xffffffff即可提权当前进程。</p>
<p><img src="lpe.png" alt="lpe"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/">https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ZecOps/CVE-2020-0796-RCE-POC">https://github.com/ZecOps/CVE-2020-0796-RCE-POC</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>